---
title:  Consuming FaultContract with Restful WCF services
date:  07/16/2010 16:48:54
permalink:  "/2010/07/16/consuming-faultcontract-with-restful-wcf-services/"
categories:
- Solution
tags:
- API
---
<p>I’ve learned something new this morning while doing a proof-of-concept around WCF REST services.</p>  <p>I did a little WPF demo app both hosting and consuming web services.&#160; I was trying to handle faults properly, using fault contracts.&#160; I had experience with SOAP-based WCF web services, so I went the motions, starting by creating a fault contract:</p>  <p><font color="#800080" face="Courier New">[DataContract</font><a href="http://psp.com/Services/Faults&quot;)]"><font color="#800080" face="Courier New">]</font></a><font color="#800080" face="Courier New">     <br />public class WrongInteger       <br />{       <br />&#160;&#160;&#160; [DataMember]       <br />&#160;&#160;&#160; public int Value { get; set; }       <br />}</font></p>  <p>A fault contract is just a data contract that you throw with an exception.</p>  <p>Then I declared that my service operation can raise that fault:</p>  <p><font color="#800080" face="Courier New">[WebInvoke(Method = &quot;PUT&quot;)]      <br />[OperationContract]       <br /><strong>[FaultContract(typeof(WrongInteger))]</strong>       <br />void PushInteger(int a); </font></p>  <p>Then I implemented the operation, throwing the usual fault exception:</p>  <p><font color="#800080" face="Courier New">&#160; void IPushService.PushInteger(int a)      <br />&#160; {       <br />&#160;&#160;&#160; if (a == 2)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new FaultException&lt;WrongInteger&gt;(new WrongInteger { Value = 2 });       <br />&#160;&#160;&#160; }       <br />&#160; }</font></p>  <p>This code works fine if you’re using SOAP WCF services.&#160; But with REST WCF services, your HTTP response will just be gibberish with an status of <em>bad request</em>.</p>  <p>Digging on the web I found there’s actually a new class, <em>WebFaultException</em>, derived from <em>FaultException</em> that you must use with REST web services:</p>  <p><font color="#800080" face="Courier New">void IPushService.PushInteger(int a)      <br />{       <br />&#160;&#160;&#160; if (a == 2)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new WebFaultException&lt;WrongInteger&gt;(new WrongInteger { Value = 2 }, HttpStatusCode.InternalServerError);       <br />&#160;&#160;&#160; }       <br />}</font></p>  <p>This will spit out the serialized fault contract into the http-response.&#160; Now for the client side code</p>  <p><font color="#800080" face="Courier New">using (WebChannelFactory&lt;IPushService&gt; factory = new WebChannelFactory&lt;IPushService&gt;(&quot;myService&quot;))      <br />{       <br />&#160;&#160;&#160; IPushService service = factory.CreateChannel(); </font></p>  <p><font color="#800080" face="Courier New">&#160;&#160;&#160; try      <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; service.PushInteger(2);       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; catch (WebFaultException&lt;WrongInteger&gt; ex)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dispatcher.Invoke((Action)delegate       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(string.Format(&quot;Expected exception:&#160; {0}, {1}&quot;, ex.Message, ex.Detail.Value));       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; });       <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; catch (Exception ex)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Dispatcher.Invoke((Action)delegate       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; MessageBox.Show(ex.Message);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; });       <br />&#160;&#160;&#160; }       <br />}</font></p>  <p>Well, another surprise, that doesn’t work either.&#160; The thrown exception isn’t a fault exception, it’s a protocol exception.</p>  <p>I haven’t found a way to make this work.&#160; Actually, I’ve read that you should craft HTTP request by hand and look at the http-response in order to get your fault.</p>  <p>Well, that’s a bit of a disappointment!&#160; It seems that the fault scenario wasn’t taught through from the get-go.&#160; For instance, the <em>WebFaultException</em> class is new in .NET 4.0.&#160; So in .NET 3.5, you couldn’t fault:&#160; your exceptions would just be generic exceptions.&#160; Now we can transmit a fault but we can’t consume it.&#160; Maybe in .NET 5.0…</p>  <p>It’s especially frustrating since it would be easy to write a WCF inspector to do that job…</p>  <p>If you find a more elegant way, please let me know!</p>