---
title: Sharing Data Contracts between clients & servers with WCF Data Services
date: 2010-11-17 19:40:00 -05:00
permalink: /2010/11/17/sharing-data-contracts-between-clients-servers-with-wcf-data-services/
categories:
- Solution
tags:
- API
---
<p>I’ve been <a href="http://vincentlauzon.wordpress.com/2010/07/05/overview-of-odata-on-code-project/">blogging</a> a bit about the <a href="http://odata.org/">OData</a> protocol put forward by Microsoft and even wrote an <a href="http://www.codeproject.com/KB/database/OverviewOData.aspx">article about it</a> on <a href="http://www.codeproject.com/">Code Project</a>.&#160; That article is supposed to be followed by others about WCF Data Services, the .NET implementation of OData, well…&#160; stay tuned!</p>  <p><a href="http://services.odata.org/website/odata.svc"><img style="display:inline;margin:0 20px 0 0;" alt="odata" align="left" src="http://www.odata.org/images/OData_logo_MS_small.png" /></a> I love that OData protocol.&#160; For me it finally brings forward the vision of web services replacing a database for data access and business logic.&#160; What was missing from SOAP web services was the ability to query.&#160; So yes, you could expose your data on the web, but you had to know in advance what type of query your clients will need.&#160; If you were not sure, you would pretty much end up with the antics <em>GetCustomerByID</em>, <em>GetCustomers</em>, <em>GetCustomersByContractID</em>, <em>GetCustomersByFirstName</em>, <em>SearchCustomerByName</em>, <em>GetCustomersWhoWasInTheLobbyWithAPipeWrench</em> and the like.&#160; All those web services were doing only one thing, being a tin adapter to your back-end store.&#160; Each time I saw those it reminded me that Web Service was a young technology and SQL was a much more mature one.</p>  <p>With OData that changed a little since you can now query your web services, so one web service implementation should satisfy most of your client needs for read-operations.&#160; Now, if like me you thought SOAP Web Services was a young and immature technology, wait until you meet OData and its .NET implementation WCF Data Services.</p>  <p>WCF Data Services has very little to do with WCF beside being an API for services exposed on the web.&#160; Most of WCF pipeline is absent, the ABC (Address, Binding &amp; Contract) of WCF is nowhere to be found and when it doesn’t work, you get a nice “resource not found” message on your browser as the only troubleshooting information.</p>  <p>Nevertheless, it does get the job done and exposes OData endpoints which are quite great and versatile.&#160; With .NET 4.0, WCF Data Services got some improvements too.&#160; A greater querying capabilities (e.g. ability to only count an entity set), interceptors and…&#160; service operations.</p>  <p>Service operations really fills the gap missing between a SOAP web services with parameters and a simple OData where you expose an Entity set.&#160; A service operations allows you to define an operation with parameters but where its result can be furthered queried (and filtered) by the client.</p>  <p>Now the client-side story isn’t as neat as WCF in general.&#160; With WCF you can share your service and data contracts between your server and your client.&#160; This isn’t always what you would like to do, but it’s a very useful scenario and allow you to share entities between the client and the server and enables you to share component dealing with those entities.&#160; The key API there is <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.channelfactory.aspx">ChannelFactory</a> ; instead of using Visual Studio or a command-line tool to generate a proxy, you let that class generate it from your service contract.&#160; It works very well.</p>  <p>This doesn’t exist with WCF Data Services.&#160; You’re sort of force to generate proxies with Visual Studio or command tools.&#160; This duplicates your types between your server and client and doesn’t allow you to have components (e.g. business logic) shared between the server and client using data entities.&#160; As an extra, the generation tools don’t support Service Operations at all.</p>  <p>In order to use service operation on the client-side, you need to amend the generated proxy.&#160; Shayne Burgess has a very good <a href="http://blogs.msdn.com/b/astoriateam/archive/2010/05/26/service-operations-and-the-wcf-data-services-client.aspx">blog entry</a> explaining how to do it.&#160; Actually, I got inspired by that blog entry to write client proxies by hand, allowing us to share data entities across tiers.&#160; Here is how to do it.</p>  <p>First you need a service operation.&#160; You can learn how to do that <a href="http://msdn.microsoft.com/en-us/library/cc668788.aspx">here</a>.&#160; The twist we’re going to give here is to define an interface for the model, another one for the service operations and one containing both.&#160; The reason to split those interfaces is due to the service operations being implemented in the data service directly while the non-service operations are in the data model itself.</p>  <blockquote>   <p>public interface IPocQueryService : IPocQueryModel, IPocQueryOperations     <br />{      <br />} </p> public interface IPocQueryModel    <br />{    <br />&#160;&#160;&#160; IQueryable&lt;FileInfoData&gt; Files { get; }    <br />}    <p>&#160;</p>    <p>public interface IPocQueryOperations     <br />{      <br />&#160;&#160;&#160; IQueryable&lt;FileInfoData&gt; GetFilesWithParties(int minPartyCount);      <br />} </p> </blockquote>  <p>Now we can define our client-proxy.</p>  <blockquote>   <p>public class PocQueryServiceProxy : DataServiceContext, IPocQueryService     <br />{      <br />&#160;&#160;&#160; #region Constructor      <br />&#160;&#160;&#160; public static IPocQueryService CreateProxy(Uri serviceRoot)      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return new PocQueryServiceProxy(serviceRoot);      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; private PocQueryServiceProxy(Uri serviceRoot)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; : base(serviceRoot)      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160; }      <br />&#160;&#160;&#160; #endregion </p>    <p>&#160;&#160;&#160; IQueryable&lt;FileInfoData&gt; IPocQueryModel.Files     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; get { return CreateQuery&lt;FileInfoData&gt;(&quot;Files&quot;); }      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; IQueryable&lt;FileInfoData&gt; IPocQueryOperations.GetFilesWithParties(int minPartyCount)     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return CreateQuery&lt;FileInfoData&gt;(&quot;GetFilesWithParties&quot;).AddQueryOption(&quot;minPartyCount&quot;, minPartyCount);      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>On the client side, we can use the proxy as if we were talking directly to the DB.</p>  <blockquote>   <p>var service = PocQueryServiceProxy.CreateProxy(builder.Uri);     <br />var files = from m in service.Files      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; where m.ID.Contains(&quot;M&quot;)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; orderby m.ID descending      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select m;      <br />var files2 = service.GetFilesWithParties(2); </p> </blockquote>  <p>I’m not a huge fan of having so many interfaces for such a simple solution.&#160; We could have only one and use it for the proxy only.&#160; But then we would be loosely coupled with the server, which is what I am trying to avoid by sharing the interfaces on the client &amp; server.</p>