---
title:  Mocking Dependencies != IoC (or at least it doesn’t have to)
date:  05/06/2012 00:37:00
permalink:  "/2012/05/05/mocking-dependencies-ioc-or-at-least-it-doesnt-have-to/"
categories:
- Solution
tags:
- .NET
---
<p>Since I met the concept of <em><a href="http://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a></em> (IoC) I’ve been a big fan!&#160; What an elegant way to externalize dependencies and decouple a component from all the components it depends on.&#160; No longer is a component initializing a dependency initially coupling itself in a hard way.</p>  <p>A nice side-effect is that an IoC-compliant component is easier to test:&#160; you have access to all its dependencies and you can replace them with mocks.</p>  <p>Since then I’ve integrated some form or another of IoC pattern.&#160; A typical implementation is to use an IoC container.&#160; I’ve worked mainly with <a href="http://msdn.microsoft.com/en-us/library/ff663144.aspx">Unity</a> (from Microsoft Enterprise Library) and <a href="http://www.springframework.net/">Spring.NET</a>.&#160; This works marvel:&#160; you configure all dependencies in an XML config file and you components are all independent, bound only by interfaces.</p>  <p>Then you do that on a big project.&#160; You end up with a huge collection of XML config with class-name in XML.&#160; It becomes hard to troubleshoot because component A needs component B than needs component C and bang!&#160; component C has a property set to a type that has changed (name refactoring for instance) and now the instantiation of A fails with a phony message.</p>  <p>I remember reading somewhere in a Java Community that Spring was a framework to translate an XML file into an exception stack!&#160; Ok, it’s an harsh comment about IoC, but I agree that by experience, there is a toll to pay to use that pattern and that price must be weighted with the benefits.</p>  <p>The benefits of IoC are obvious when you have a lot of components from different assemblies bound together.&#160; With IoC, all the binding are bootstrapped in one place, in the IoC container.</p>  <p>Now if you have another strategy to loosely couple your components (e.g. services, layers, etc.), the benefit is less obvious because your components are then typically referring components in the same assembly.</p>  <p>Plus, let’s face it, an IoC-compliant component is annoying to use.&#160; For instance, if we look at this component:</p>  <blockquote>   <p>public class MyComponent     <br />{      <br />&#160;&#160;&#160; public DbProviderFactory Provider { get; private set; }      <br />&#160;&#160;&#160; public DbConnection Connection { get; private set; }</p>    <p>&#160;&#160;&#160; public void InvokeLogic()     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160; Use Connection &amp; Command      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>When I instantiate <em>MyComponent</em>, it will throw a null-exception when I invoke <em>InvokeLogic</em>.&#160; This is really annoying:&#160; I need to construct everything to use that component.</p>  <p>You can circumvent that problem by passing dependency in the constructor.&#160; This way you cannot instantiate a dysfunctional component.&#160; But constructor-passed dependencies bring their lots of problem.&#160; What if I want to mock only one sub-component?&#160; I still have to construct all the dependencies.</p>  <p>Now, as I said, if there are benefits because your components are spread around the place and you want to minimize dependencies, the price is justified.&#160; If all you want to do is to be able to mock some dependencies but in the normal (non test) scenarios you just want to instantiate components, keep reading!</p>  <p>In those scenarios, what I really want is:</p>  <ul>   <li>Expose dependencies so a consumer can replace them</li>    <li>Have default implementation for those dependencies so a consumer can simply instantiate the component without setup-ing all its dependencies.</li>    <li>Have those default implementation lazy loaded because they might actually fail in my testing environment (e.g. they might look for a connection string in my config file and there are none).</li> </ul>  <p>Ok, it sounds like the solution will use the <a href="http://msdn.microsoft.com/en-us/library/dd642331.aspx">Lazy&lt;T&gt;</a> class of .NET Framework.&#160; Actually, a very simple solution to that is something in the lines of:</p>  <blockquote>   <p>public class MyTestableComponent     <br />{      <br />&#160;&#160;&#160; public Lazy&lt;DbProviderFactory&gt; Provider { get; set; }      <br />&#160;&#160;&#160; public Lazy&lt;DbConnection&gt; Connection { get; set; }</p>    <p>&#160;&#160;&#160; public MyTestableComponent()     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Provider = new Lazy&lt;DbProviderFactory&gt;(() =&gt; SqlClientFactory.Instance);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Connection = new Lazy&lt;DbConnection&gt;(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delegate      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var conn = Provider.Value.CreateConnection();</p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; conn.ConnectionString = &quot;Data Source=.;Initial Catalog=myDataBase;Integrated Security=SSPI;&quot;;</p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return conn;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; });      <br />&#160;&#160;&#160; }</p>    <p>&#160;&#160;&#160; public void InvokeLogic()     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160; Use Connection &amp; Command      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>So what are we doing here?&#160; We expose dependencies through properties.&#160; But the properties are actually lazy evaluation of the real dependency.&#160; So when you new your component, no dependencies are evaluated.</p>  <p>The default implementation of dependencies is done in the constructor.</p>  <p>Since Lazy&lt;T&gt; is using delegates and we are using closure (e.g. in the <em>Connection</em> property we fetch <em>this.Provider</em> from the surrounding context as opposed to a parameter passed to the delegate), we can even depend on other properties, as this consumer code demonstrate:</p>  <blockquote>   <p>var comp = new MyTestableComponent();</p>    <p>Console.WriteLine(     <br />&#160;&#160;&#160; &quot;{0} : \&quot;{1}\&quot;&quot;,      <br />&#160;&#160;&#160; comp.Connection.Value.ToString(),      <br />&#160;&#160;&#160; comp.Connection.Value.ConnectionString);      <br />Console.WriteLine();</p>    <p>comp = new MyTestableComponent();     <br />comp.Provider = new Lazy&lt;DbProviderFactory&gt;(() =&gt; OdbcFactory.Instance);</p>    <p>Console.WriteLine(     <br />&#160;&#160;&#160; &quot;{0} : \&quot;{1}\&quot;&quot;,      <br />&#160;&#160;&#160; comp.Connection.Value.ToString(),      <br />&#160;&#160;&#160; comp.Connection.Value.ConnectionString);</p> </blockquote>  <p>This outputs</p>  <blockquote>   <p><font color="#0000ff">System.Data.SqlClient.SqlConnection</font> : &quot;Data Source=.;Initial Catalog=myDataBase;Integrated Security=SSPI;&quot;</p>    <p><font color="#0000ff">System.Data.Odbc.OdbcConnection</font> : &quot;Data Source=.;Initial Catalog=myDataBase;Integrated Security=SSPI;&quot;</p> </blockquote>  <p>Hence we were able to change only the provider and the connection property still get initialized with the new provider and configured the same way.&#160; Nice &amp; simple.</p>  <p>If you do not like having <em>Lazy&lt;T&gt;</em> flying around, you’ll need to expose <em>T</em> properties with a private variable of type <em>Lazy&lt;T&gt;</em> and some method to override them.&#160; I don’t mind exposing that I’m lazy <img style="border-style:none;" class="wlEmoticon wlEmoticon-winkingsmile" alt="Winking smile" src="assets/2012/5/mocking-dependencies-ioc-or-at-least-it-doesnt-have-to/wlemoticon-winkingsmile.png" /></p>  <p>The biggest problem with this approach is if you want to mock only one sub-sub-sub-sub component.&#160; You then need to let the lazy load happened and then override that buried property.</p>  <p>This solution gives us mock-ability without the weight of IoC where it isn’t needed.</p>  <p>Ever used a similar solution?&#160; Do you see any weaknesses?</p>