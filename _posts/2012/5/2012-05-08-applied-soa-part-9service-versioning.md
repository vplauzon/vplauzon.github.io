---
title:  Applied SOA: Part 9–Service Versioning
date:  2012-05-08 23:59:00 +00:00
permalink:  "/2012/05/08/applied-soa-part-9service-versioning/"
categories:
- Solution
tags:
- API
---
<p>This is part of a series of blog post about Applied SOA. The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/17/applied-soa-part-1-introduction/">Introduction</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/11/27/applied-soa-part-2-soa-basics/">SOA Basics</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/11/29/applied-soa-part-3-service-discovery-process/">Service Discovery Process</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/09/applied-soa-part-4-service-taxonomy/">Service Taxonomy</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/13/applied-soa-part-5-interoperability/">Interoperability</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/21/applied-soa-part-6service-composition/">Service Composition</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2012/01/06/applied-soa-part-7system-consistency/">System Consistency</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2012/02/09/applied-soa-part-8security/">Security</a> </li> </ul>  <p>In this article, I’ll cover Service Versioning.</p>  <p>In SOA a Service usually has many consumers &amp; it should be able to evolve independently of its consumers.&#160; By that I mean that when a Service evolves, consumers shouldn’t break.&#160; Otherwise we would have a hard time to evolve services.</p>  <p>We can do quite a bit of changes to a Service without breaking existing consumers logic. For instance:</p>  <ul>   <li>Changing Service implementation details, i.e. not its behaviour, e.g. tap to another Database, add logging, route information to different systems, etc. </li>    <li>Adding a new Service Operation to a Service </li>    <li>Adding optional data-items in message payload </li> </ul>  <p>What needs to remain stable for consumers to continue to operate normally is called the Service contract:&#160; Service behaviours and information exchange patterns, i.e. schemas &amp; bindings.&#160; This definition of Service contract is broader than <a href="http://msdn.microsoft.com/en-us/library/ms733070.aspx">WCF Service Contracts</a>.</p>  <p>Service Contract can be backward compatible, i.e. a new Service Contract can support the same consumer base (for instance when we add a Service Operation without altering existing ones).</p>  <p>We need to version Service Contracts in order to accommodate for breaking changes.&#160; When an evolution of a Service requires to introduce breaking change in its Contract, we need to support the current version until all consumers can be moved to the new version.</p>  <p>We want to keep track of two types of Service Versions:&#160; breaking ones and non-breaking changes.&#160; Breaking change versions require multiple versions to co-exist in order to support different consumers while non-breaking change versions are useful to determine the capacity of a Service.</p>  <p>A typical versioning scheme is to track breaking change versions with major version number while non-breaking versions are tracked with minor version number.&#160; This is the scheme used by Windows Azure REST services for instance.</p>  <h3>Concurrent Service Versions</h3>  <p>Maintaining more than one Service Contract version at the same time is notoriously hard.&#160; Typically you introduce breaking changes because either a business process or a back-end system imposes that change on you.&#160; Those changes are often hard to burry under a legacy Service Contract version.</p>  <p>That problem isn’t unlike its equivalent in the component world.&#160; How do you evolve a component?&#160; You version its interface and try to keep old interface backward compatible as long as you can before deprecating them.</p>  <h3>Service Behaviours</h3>  <p>Just a word about Service Behaviours:&#160; those are encapsulated in Service Contract along operation signatures.&#160; Behaviours are any logic surfaced to the consumer, as opposed to implementation details which aren’t surfaced.</p>  <p>For example, if a Service encapsulates access to a Database, a consumer won’t know which Database the Service read / writes from.&#160; The exact Database is therefore an implementation detail.</p>  <p>On the other hand, if a Service operation takes an integer in input and validates the input as being greater than zero by raising a fault if that pre-condition isn’t met, that becomes a behaviour.&#160; A consumer depends on that validation:&#160; if a change requires the input to be greater than 5, consumer sending values between 1 and 5 will break.</p>  <p>Service Behaviours are hard to document with tools.&#160; For instance, WCF Service Contracts do not capture pre &amp; post conditions.&#160; This typically require documentation on the side.</p>