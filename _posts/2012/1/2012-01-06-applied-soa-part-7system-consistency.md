---
title: 'Applied SOA:  Part 7–System Consistency'
date: 2012-01-06 20:49:00 -05:00
permalink: /2012/01/06/applied-soa-part-7system-consistency/
categories:
- Solution
tags:
- API
---
<p>This is part of a series of blog post about Applied SOA. The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/17/applied-soa-part-1-introduction/">Introduction</a> </li>    <li><a title="Preview “Applied SOA- Part 2 – SOA Basics”" href="http://vincentlauzon.wordpress.com/2011/11/27/applied-soa-part-2-soa-basics/">SOA Basics</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/11/29/applied-soa-part-3-service-discovery-process/">Service Discovery Process</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/09/applied-soa-part-4-service-taxonomy/">Service Taxonomy</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/13/applied-soa-part-5-interoperability/">Interoperability</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/21/applied-soa-part-6service-composition/">Service Composition</a></li> </ul>  <p>In this article, I’ll cover system consistency.&#160; In every distributed solution, a major concern should be consistency.&#160; How to you ensure that different moving parts in your solution create a consistent state?</p>  <p>Many patterns and solutions exist to address that problem.&#160; We’ll look at a few and see how it impacts other attributes of a SOA solution.</p>  <h3>Distributed ACID Transaction</h3>  <p>First solution that pops to mind is ACID transactions.&#160; <a href="http://en.wikipedia.org/wiki/ACID">ACID transaction</a> is a very elegant and very mature technology allowing distributed parts of a system to remain consistent.&#160; I won’t go into details here and just assume you know the basics of ACID transactions.</p>  <p>ACID transactions can actually solve the consistency problem in a SOA solution as well.&#160; We would need to use distributed transactions (through WS-Atomic protocol for instance) where transaction would span through the calling tree of a service.&#160; This way, everything in the calling tree would be part of the same transaction and would either commit or rollback as a whole.&#160; It would conflict with solution attributes of SOA though.</p>  <p>The main attribute it would conflict with is service autonomy / isolation.&#160; A distributed transaction implies that a calling service holds lock in a composed service for a certain duration.&#160; This means the composed service can’t guarantee to other callers it can process their requests.&#160; That control has been partially externalized by the transaction.&#160; It breaks the trust boundaries between services:&#160; a service now needs to trust services invoking those services will hold locks on its resources.&#160; Locks also limit scalability of services.</p>  <p>ACID transactions are excellent at ensuring data consistency but they come at a high cost.&#160; This cost is deemed unacceptable in Cloud Computing because of scalability.&#160; The same goes for services invoked across trust boundaries (e.g. B2B services).</p>  <h3>Compensation</h3>  <p>The typical fall-back pattern when transactions aren’t appropriate is Workflow + Compensation.&#160; With this pattern, each service expose a rollback, or compensation, logic so that a calling service can call an operation and later on call another operation in order to rollback the effect of the previous transaction.&#160; This typically assume that some sort of workflow engine is at the root of all those calls, orchestrating the service call chain.</p>  <p>This patterns also work and solve the consistency problem.&#160; It introduces different compromises.&#160; For instance, services must trust the workflow engine to take care of the consistency.&#160; Mostly, it is a more complicated solution.&#160; Instead of relying on a system (the transaction coordinator) to take care of compensation, you basically must implement it yourself.</p>  <p>Above the technical difficulty, it might be difficult to compensate after a certain lapse of time.&#160; This would be a business problem.&#160; A typical example is A puts $100 in B’s account, B pays a $90 bill, A wants to rollback its original transaction, but the money is already spent, what can we do?&#160; This is where the orchestrating workflow will get more and more complicated.</p>  <h3>Conclusion</h3>  <p>We’ve seen the two basic patterns for consistency.&#160; Typically we mix them together.&#160; For instance, a service implementation will use ACID transaction internally to ensure consistency internally.&#160; For read-only operations, composition without distributed transaction can be ok in many system where changes aren’t happening too quickly.&#160; This typically leaves you with only a small set of services requiring state-altering composition.&#160; Those often are business processes and are best handled in a Workflow engine.</p>