---
title:  Recreating VMs in Azure
date:  2016-05-30 23:14:34 -04:00
permalink:  "/2016/05/30/recreating-vms-in-azure/"
categories:
- Solution
tags:
- Virtual Machines
---
<a href="http://vincentlauzon.files.wordpress.com/2016/05/darkphoenix1.jpg"><img style="background-image:none;float:right;padding-top:0;padding-left:0;margin:0 10px 0 0;display:inline;padding-right:0;border:0;" title="From http://www.hdwalls.xyz/" src="http://vincentlauzon.files.wordpress.com/2016/05/darkphoenix1_thumb.jpg" alt="From http://www.hdwalls.xyz/" width="325" height="280" align="right" border="0" /></a>In this article I’m going to explain how to destroy VMs, keep their disks on the backburner and re-create them later.

Why would you do that?

After all, you can shut down VMs and not be charged for it.  You can later restart them and incur the compute cost only once it’s started.  So why destroy / recreate VMs?

In general, because you get an <a href="https://azure.microsoft.com/en-us/blog/allocation-failure-and-remediation/" target="_blank">allocation failure</a>.  I did touch upon that in a <a href="https://vincentlauzon.com/2016/02/05/shutting-down-vms-on-schedule-in-azure/">past article</a>.

Azure Data Centers are packaged in stamps (group of physical servers).  A dirty secret of Azure is that your VM stays in a stamp even if you shut it down.  So if you need to move your VM, you need to destroy it and recreate it.

Two typical use cases:
<ul>
 	<li>You want to change the size of your VM to a size unsupported by its current stamp (e.g. D-series stamp often do not support G-series VMs)</li>
 	<li>You want to restart your VM after a bit of time and the stamp is full so you can bring your VM in</li>
</ul>
Frankly, this is all sad and I wish it will be addresses in a future service update.  In the mean time, we do need a way to easily destroy / recreate VMs.

Before I dive into it, there is of course no magic and you have to make sure the Azure region you deploy in support the service you’re trying to deploy.  Many services aren’t available everywhere (e.g. G-series VMs, Cortana Analytics services, etc.).  Consulting the <a href="https://azure.microsoft.com/en-us/regions/#services" target="_blank">list of services per region</a> to validate your choice.

The technique I show here is based on a my <a href="https://alexandrebrisebois.wordpress.com/2015/11/29/on-off-done-right-on-azure/" target="_blank">colleague’s article</a>.  Alexandre published that article before the <a href="https://vincentlauzon.com/2016/05/29/azure-export-template-your-new-best-friend/">Export Template feature</a> was made available.  This article will therefore use ARM templates generated by <em>Export Template</em> in order to resuscitate VMs.

An alternative approach would be to use PowerShell scripts to recreate the VMs.

Also I based this article on the deployment of a <a href="https://azure.microsoft.com/en-us/marketplace/partners/sqlvm/sqlserveralwaysonsqlvmsample/" target="_blank">SQL Server Always on Cluster</a> (5 VMs).
<h2>Exporting current state</h2>
I assume you have a running environment within an Azure Resource Group.

The first step is to export your Azure Resource Group as an ARM Template.  Refer to <a href="https://vincentlauzon.com/2016/05/29/azure-export-template-your-new-best-friend/">this article</a> for details.

Save the JSON template somewhere.
<h2>Deleting VMs</h2>
You can now delete your VMs.  You might want to hook that to a Run Book as I did in <a href="https://vincentlauzon.com/2016/02/05/shutting-down-vms-on-schedule-in-azure/">Shutting down VMs on schedule in Azure</a> (e.g. to shut down the VMs frequently) or might just do it once (e.g. to resize VM once).

One way to do it, with PowerShell, is to use the following command:

[code language="PowerShell"]

Get-AzureRmVM | Where-Object {$_.ResourceGroupName -eq &quot;NAME OF YOUR RESOURCE GROUP&quot;} | Select-Object Name, ResourceGroupName | ForEach-Object {Remove-AzureRmVM -ResourceGroupName $_.ResourceGroupName -Name $_.Name -Force}

[/code]

Here I basically list the VMs within one resource group and delete them.

This will not delete the disks associated to them.  It will simply shut down the compute and de-allocate the compute resource.  Everything else, e.g. networks, subnets, availability sets, etc. stay unchanged.

If you’re afraid to delete VMs you didn’t intend to delete you can call the <em>Remove-AzureRmVM</em> explicitly on each VM.
<h2>Adapting ARM Template</h2>
Export Template does the heavy lifting.  <strong>But it can’t be used as is</strong>.

We have to make several changes to the template before being able to use it to recreate the VMs.
<ol>
 	<li>Remove <em>SecureString</em> password parameters.  We will remove all reference to those so you shouldn’t need it.  The reason is the admin password of your VM is stored on disks and will restored with those disks.  This isn’t essential, but it will avoid you being prompted for password when you’ll run the template.</li>
 	<li>Change all the <em>createOption</em> attributes to <em>Attach</em>.  This tells Azure to simply take the disks in storage as opposed to creating a disk from a generalized image.</li>
 	<li>Just next to the <em>createOption</em> for the os-disk, add a <em>osType</em> attribute of value either <em>Windows</em> or <em>Linux</em>.</li>
 	<li>Remove (or comment out) a few properties:
<ul>
 	<li><em>imageReference</em>:  that is under <em>storageProfile</em></li>
 	<li><em>osProfile</em>:  that is after <em>storageProfile</em></li>
 	<li><em>diskSizeGB</em>:  that is under <u>each</u> <em>dataDisks</em></li>
</ul>
</li>
</ol>
Here’s how the osDisk property should look after modifications

[code language="javascript"]
&quot;osDisk&quot;: {
&quot;name&quot;: &quot;osdisk&quot;,
&quot;osType&quot;: &quot;Windows&quot;,
&quot;createOption&quot;: &quot;Attach&quot;,
&quot;vhd&quot;: {

[/code]

After this little massage of the ARM template you should be able to run the template and recreate your VMs as is.
<h2>Making your own modifications</h2>
In some cases you might want to modify the ARM template some more.  For instance, by changing the size of VMs.  You can do this now.
<h3>Caveat around availability set</h3>
There are some funny behaviours around availability sets and VM size I found while writing this article.

One thing is that you can’t change the availability set of a VM (as of this writing).  So you need to get it right the first time.

Another is that a load balancer needs to have VMs under the same availability set.  You can’t have two or VMs without availability sets.

The best one is that you can’t have an availability set with VMs of different size families.  In the case I used, i.e. the SQL Always on cluster, the SQL availability set has two SQL nodes and one witness in it.  The original template let you only configure those as D-series.  You can’t change them to G-series later on and this is one of the reason you’ll want to use the technique laid out here.  But…  even then, you can’t have your witness as a D-series and the SQL nodes as G-series.  So you need to have at least a GS-1 as the witness (which is a bit ridiculous considering what a witness does in a SQL cluster).

That last one cost me a few hours so I hope reading this you can avoid wasting as much on your side!
<h2>Running the template</h2>
You can then run the template.

My favorite tool for that is Visual Studio but you can do it directly in the portal (see <a href="https://azure.microsoft.com/en-us/documentation/articles/mytemplates-getstarted/" target="_blank">this article</a> for guidance).
<h2>Conclusion</h2>
Destroying / recreating your VMs will ensure you to have a more robust restart experience.

It also allows you to get around other problems such as re-configuring multiple VMs at once, e.g. changing the size of all VMs in an availability set.

Thanks to <em>Export Template</em> feature, it isn’t as much work as it used to be a few months ago.