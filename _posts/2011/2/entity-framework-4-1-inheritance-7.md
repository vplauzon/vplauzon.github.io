---
title: 'Entity Framework 4.1: Inheritance (7)'
date: 2011-04-19 17:32:00 -07:00
permalink: /2011/04/19/entity-framework-4-1-inheritance-7/
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about Entity Framework 4.1.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/04/03/entity-framework-4-1-basics-1/">Basics (1)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/06/entity-framework-4-1-override-conventions-2/">Override conventions (2)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/11/entity-framework-4-1-deep-fetch-vs-lazy-load-3/">Deep Fetch vs Lazy Load (3)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/13/entity-framework-4-1-complex-types-4/">Complex Types (4)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/15/entity-framework-4-1-many-to-many-relationships-5/">Many to Many Relationships (5)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/17/entity-framework-4-1-optimistic-concurrency-6/">Optimistic Concurrency (6)</a> </li> </ul>  <p>In this article, I’ll cover inheritance.</p>  <p>I must say that I did struggle a fair bit with this feature.&#160; Like the rest of EF 4.1, it isn’t officially documented, but it seems the API changed substantially between CTPs and RC, so the blog posts out there were a bit misleading for me.</p>  <p>A good source for me was <a href="http://weblogs.asp.net/manavi/archive/2011/01/03/inheritance-mapping-strategies-with-entity-framework-code-first-ctp5-part-3-table-per-concrete-type-tpc-and-choosing-strategy-guidelines.aspx">Morteza Manavi’s blog</a>, which I recommend.</p>  <p>In ORM literature, there are three ways to map tables to object hierarchies (i.e. classes related to each others with inheritance relations):</p>  <ul>   <li>Table per Type (TPT):&#160; for each class in the hierarchy, there is a table in the DB, related to each others with FK </li>    <li>Table per Hierarchy (TPH):&#160; there is only one table for the entire hierarchy with all possible data in it </li>    <li>Table per Concrete Type (TPC):&#160; a bit of mix of the other two, there is one table for each concrete type, which flattens the abstract types as in TPH </li> </ul>  <p>Here I’m going to cover TPT &amp; TPH.&#160; The beauty of EF 4.1 is that you can mix those ways of dealing with the mapping within one hierarchy, as I’ll show.</p>  <p>Let’s start with table per type.&#160; Here I define a simple hierarchy with one abstract base class and two derived classes:</p>  <blockquote>   <p>public abstract class PersonBase      <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public int PersonID { get; set; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; [Required]       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public string FirstName { get; set; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; [Required]       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public string LastName { get; set; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public int Age { get; set; }       <br />&#160;&#160;&#160; }</p>    <p>public class Worker : PersonBase      <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public decimal AnnualSalary { get; set; }       <br />&#160;&#160;&#160; }</p>    <p>public class Retired : PersonBase      <br />{       <br />&#160;&#160;&#160; public decimal MonthlyPension { get; set; }       <br />} </p> </blockquote>  <p>We need to tell the model builder how to map those classes to tables:</p>  <blockquote>   <p>protected override void OnModelCreating(DbModelBuilder modelBuilder)      <br />{       <br />&#160;&#160;&#160; base.OnModelCreating(modelBuilder); </p>    <p>&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().HasKey(x =&gt; x.PersonID);      <br />&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().Property(x =&gt; x.PersonID)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);       <br />&#160;&#160;&#160; //&#160;&#160;&#160; TPT mapping       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().<font color="#ff0000">ToTable</font>(&quot;tpt.Person&quot;);       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;Worker&gt;().<font color="#ff0000">ToTable</font>(&quot;tpt.Worker&quot;);       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;Retired&gt;().<font color="#ff0000">ToTable</font>(&quot;tpt.Retired&quot;);       <br />} </p> </blockquote>  <p>We use simple table name overrides, but with this information the model builder knows it has to build the database with TPT:</p>  <p><a href="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image3.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image_thumb3.png" width="496" height="321" /></a> </p>  <p>If we run some code against that model, we can appreciate how we can leverage the mapping.&#160; Basically, we expose one and only one <em>DbSet</em>:&#160; a collection of <em>PersonBase</em>.&#160; EF takes care of managing which real type each member should be.</p>  <blockquote>   <p>public static void ManageTPT()      <br />{       <br />&#160;&#160;&#160; using (var context1 = new TptContext())       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var worker = new Worker       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; AnnualSalary = 20000,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Age = 25,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; FirstName = &quot;Joe&quot;,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LastName = &quot;Plumber&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; };       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var retired = new Retired       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; MonthlyPension = 1500,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Age = 22,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; FirstName = &quot;Mike&quot;,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LastName = &quot;Smith&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; };       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Make sure the tables are empty...       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach (var entity in context1.Persons)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Remove(entity);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Add(worker);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Add(retired); </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.SaveChanges();      <br />&#160;&#160;&#160; }       <br />&#160;&#160;&#160; using (var context2 = new TptContext())       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Persons count:&#160; &quot; + context2.Persons.OfType&lt;PersonBase&gt;().Count());       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Worker:&#160; &quot; + context2.Persons.OfType&lt;Worker&gt;().Count());       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Retired:&#160; &quot; + context2.Persons.OfType&lt;Retired&gt;().Count());       <br />&#160;&#160;&#160; }       <br />} </p> </blockquote>  <p>This is quite powerful since we can access the <em>Worker</em>s only and EF takes care of accessing only the Worker table.</p>  <p>TPH is actually the default for EF.&#160; We could simply comment out lines from the previous example to fallback on the default to see the general mechanic:</p>  <blockquote>   <p>protected override void OnModelCreating(DbModelBuilder modelBuilder)      <br />{       <br />&#160;&#160;&#160; base.OnModelCreating(modelBuilder); </p>    <p>&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().HasKey(x =&gt; x.PersonID);      <br />&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().Property(x =&gt; x.PersonID)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);       <br />&#160;&#160;&#160; //&#160;&#160;&#160; TPT mapping       <br />&#160;&#160;&#160; <font color="#8080ff">//modelBuilder.Entity&lt;PersonBase&gt;().ToTable(&quot;tpt.Person&quot;);        <br />&#160;&#160;&#160; //modelBuilder.Entity&lt;Worker&gt;().ToTable(&quot;tpt.Worker&quot;);         <br />&#160;&#160;&#160; //modelBuilder.Entity&lt;Retired&gt;().ToTable(&quot;tpt.Retired&quot;);         <br /></font>} </p> </blockquote>  <p>This results in only one table (for the entire hierarchy):</p>  <p><a href="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image4.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image_thumb4.png" width="351" height="238" /></a> </p>  <p>We notice the entire hierarchy is flatten within one table.&#160; The properties not found in the base class are automatically marked as nullable.&#160; There is also an addition:&#160; a discriminator column.&#160; If we run the previous code sample, we’ll see how this discriminator column is used by default by looking at the content of the table afterwards:</p>  <p><a href="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image5.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image_thumb5.png" width="507" height="66" /></a> </p>  <p>The discriminator column is used by EF to know which class to instantiate when it reads a row, since all classes map to the same table.</p>  <p>We can override all that.&#160; Let’s show that at the same time as showing the mix of TPH &amp; TPT.&#160; I’ll define two new subclasses of <em>Worker</em> and I want to map them both, and the <em>Worker</em> class, in one table:</p>  <blockquote>   <p>public class Manager : Worker     <br />{      <br />&#160;&#160;&#160; public int? ManagedEmployeesCount { get; set; }      <br />} </p>    <p>public class FreeLancer : Worker     <br />{      <br />&#160;&#160;&#160; [Required]      <br />&#160;&#160;&#160; public string IncCompanyName { get; set; }      <br />} </p> </blockquote>  <p>You’ll notice that each property must be null.&#160; This is a great inconvenience with TPH:&#160; every property must be nullable.&#160; Now we can instruct the model builder:</p>  <blockquote>   <p>protected override void OnModelCreating(DbModelBuilder modelBuilder)     <br />{      <br />&#160;&#160;&#160; base.OnModelCreating(modelBuilder); </p>    <p>&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().HasKey(x =&gt; x.PersonID);     <br />&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().Property(x =&gt; x.PersonID)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; TPT mapping      <br />&#160;&#160;&#160; modelBuilder.Entity&lt;PersonBase&gt;().ToTable(&quot;tpt.Person&quot;);      <br />&#160;&#160;&#160; modelBuilder.Entity&lt;Retired&gt;().ToTable(&quot;tpt.Retired&quot;);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; TPH mapping      <br />&#160;&#160;&#160; modelBuilder.Entity&lt;Worker&gt;()      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .<font color="#ff0000"><strong>Map</strong></font>&lt;FreeLancer&gt;(m =&gt; m.Requires(f =&gt; f.IncCompanyName).HasValue())      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .<font color="#ff0000"><strong>Map</strong></font>&lt;Manager&gt;(m =&gt; m.Requires(ma =&gt; ma.ManagedEmployeesCount).HasValue())      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ToTable(&quot;tph.Worker&quot;);      <br />} </p> </blockquote>  <p>Here I use one way of discriminating:&#160; I asked that a column belonging only to one class be not-null for a row to be mapped to that class.&#160; This is different than what the default does.</p>  <p>The consumer code isn’t dissimilar than TPT (you could change your mapping without impacting the consumer code):</p>  <blockquote>   <p>public static void ManageTPH()     <br />{      <br />&#160;&#160;&#160; using (var context1 = new HierarchyContext())      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var worker = new Worker      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; AnnualSalary = 20000,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Age = 25,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; FirstName = &quot;Joe&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LastName = &quot;Plumber&quot;      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; };      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var freeLancer = new FreeLancer      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Age = 22,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; FirstName = &quot;Mike&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LastName = &quot;Smith&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IncCompanyName = &quot;Mike &amp; Mike Inc&quot;      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; };      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var manager = new Manager      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Age = 43,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; FirstName = &quot;George&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; LastName = &quot;Costanza&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ManagedEmployeesCount = 12      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; };      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Make sure the tables are empty...      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach (var entity in context1.Persons)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Remove(entity);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Add(worker);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Add(freeLancer);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Persons.Add(manager); </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.SaveChanges();     <br />&#160;&#160;&#160; }      <br />&#160;&#160;&#160; using (var context2 = new HierarchyContext())      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Persons count:&#160; &quot; + context2.Persons.OfType&lt;PersonBase&gt;().Count());      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Worker:&#160; &quot; + context2.Persons.OfType&lt;Worker&gt;().Count());      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Retired:&#160; &quot; + context2.Persons.OfType&lt;Retired&gt;().Count());      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;FreeLancer:&#160; &quot; + context2.Persons.OfType&lt;FreeLancer&gt;().Count());      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Manager:&#160; &quot; + context2.Persons.OfType&lt;Manager&gt;().Count());      <br />&#160;&#160;&#160; }      <br />} </p> </blockquote>  <p>The SQL schema is, as planned, an hybrid of TPT &amp; TPH: </p>  <p><a href="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image6.png"><img style="border-bottom:0;border-left:0;display:inline;border-top:0;border-right:0;" title="image" border="0" alt="image" src="/assets/posts/2011/2/entity-framework-4-1-inheritance-7/image_thumb6.png" width="790" height="436" /></a> </p>  <p>I haven’t found the way to use a discriminator and override it.&#160; I do find this way of testing for nulls more interesting than having a discriminator column, which introduces yet more denormalization.</p>