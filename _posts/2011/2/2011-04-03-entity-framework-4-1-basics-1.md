---
title: 'Entity Framework 4.1: Basics (1)'
date: 2011-04-03 10:02:00 -07:00
permalink: /2011/04/03/entity-framework-4-1-basics-1/
categories:
- Solution
tags:
- .NET
---
<p>As <a href="http://vincentlauzon.wordpress.com/2011/03/29/entity-framework-4-1-rc-including-code-first/">I wrote a few days ago</a>, I’ve started to toy around with Entity Framework 4.1, more specifically around the features of Code First.</p>  <p>I’m currently consulting for an SOA project and I have to put forward the solution architecture for many aspect of the solution, including the data access layer.&#160; So I did quite a few POCs in order to make sure the solution I was laying down would hold.</p>  <p>As I mentioned before, the documentation is quite scarce, some related to CTP (1 to 5) with the API slightly different than what it is today.&#160; I’m going to do a series of blog entry around the topics I covered so that you don’t have to search as I had to.</p>  <p>Here’s the first entry where I’ll cover some basics.</p>  <p>As its name suggest, with code-first, you start with the code.&#160; You can create the corresponding database directly from the code, but you could also be working from an existing DB.&#160; The advantage of code-first is that your entity-classes don’t have any EF artefacts on them:&#160; they don’t derive from a specific class and they do not have funky attributes on them.&#160; Well…&#160; for the attributes, as we’ll see, that’s optional!</p>  <p>Let’s start with a simple entity model:&#160; Order and OrderDetail.&#160; We start by modelling it as classes:</p>  <blockquote>   <p>public class Order     <br />{      <br />&#160;&#160;&#160; public int OrderID { get; set; }      <br />&#160;&#160;&#160; public string OrderTitle { get; set; }      <br />&#160;&#160;&#160; public string CustomerName { get; set; }      <br />&#160;&#160;&#160; public DateTime TransactionDate { get; set; } </p>    <p>&#160;&#160;&#160; public List&lt;OrderDetail&gt; OrderDetails { get; set; }     <br />} </p>    <p>public class OrderDetail     <br />{      <br />&#160;&#160;&#160; public int OrderDetailID { get; set; }      <br />&#160;&#160;&#160; public int OrderID { get; set; }      <br />&#160;&#160;&#160; public decimal Cost { get; set; }      <br />&#160;&#160;&#160; public string ItemName { get; set; } </p>    <p>&#160;&#160;&#160; public Order Order { get; set; }     <br />}</p> </blockquote>  <p>Note the following about those classes:</p>  <ul>   <li>They do not derive from any EF classes </li>    <li>They do not use EF attributes </li>    <li>An <em>Order</em> contains a list of <em>OrderDetail</em> <strong>and</strong> an <em>OrderDetail</em> contains a reference to its <em>Order</em> </li>    <li>Each property is either </li>    <li>     <ul>       <li>A simple CLR Type (e.g. string, int, etc.) </li>        <li>An entity-type (e.g. <em>Order</em>) </li>        <li>A list of entity type (e.g. <em>List&lt;OrderDetail&gt;</em>) </li>     </ul>   </li> </ul>  <p>In order to map those class into a DB, we need a container, a database-context:</p>  <blockquote>   <p>public class MyDomainContext : DbContext     <br />{      <br />&#160;&#160;&#160; public DbSet&lt;Order&gt; Orders { get; set; }      <br />&#160;&#160;&#160; public DbSet&lt;OrderDetail&gt; OrderDetails { get; set; } </p>    <p>&#160;&#160;&#160; static MyDomainContext()     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Database.SetInitializer&lt;MyDomainContext&gt;(new DropCreateDatabaseIfModelChanges&lt;MyDomainContext&gt;());      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote> <!-- code formatted by http://manoli.net/csharpformat/ -->  <p>This class is EF-aware.&#160; It doesn’t have to sit in the same assembly than your model classes though.</p>  <p>At least a context must satisfy the following:</p>  <ul>   <li>It derives from <em>System.Data.Entity.DbContext</em> </li>    <li>It has a property for each entity set we want to expose </li>    <li>Each property is of type <em>System.Data.Entity.DbSet&lt;T&gt;</em> where <em>T</em> is the type of the entity </li>    <li>Each property is read / write (get / set) </li> </ul>  <p>With that in place, the <em>DbContext</em> base class uses reflection to pick-up the entity-sets and a bunch of convention to infer the underlying database model it should map to.</p>  <p>The conventions take decisions such as <em>for the entity of type Order, the property OrderID must be its primary key</em>.&#160; Other convention will infer the column-name (by default the property name), the column type (e.g. a string maps to nvarchar(128) and should be nvarchar(MAX) in the <a href="http://blogs.msdn.com/b/adonet/archive/2011/03/29/ef-4-1-rtw-change-to-default-maxlength-in-code-first.aspx">final version</a>), if a column is nullable (by default, all column but primary and foreign keys are nullable), etc.&#160; .&#160; We’ll see that there are ways to override those conventions.</p>  <p>We’ve added a static constructor here.&#160; The instruction in the static constructor sets a standard for the entire app-domain:&#160; when a database context is initialized, check if the schema in the database is conform to the model and if not drop the DB and recreate it.&#160; The way this is done is that EF creates a table <em>dbo.EdmMetadata</em> and persist a hash of the model schema in it.</p>  <p>If the database doesn’t exist, EF will create it.&#160; Which database?&#160; By default, it creates a DB with the name of your context on the local machine.&#160; You can override that in many ways.&#160; The simplest is to add a connection string in your configuration file with the name of the context (in my case, &quot;<em>MyDomainContext</em>&quot;).&#160; Another way is to implement a constructor and call the non-default base-class constructor in it.</p>  <p>In the next blob entry, I’ll show how to override the conventions.</p>