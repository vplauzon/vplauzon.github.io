---
title: 'Entity Framework 4.1: Override conventions (2)'
date: 2011-04-06 17:52:00 -07:00
permalink: /2011/04/06/entity-framework-4-1-override-conventions-2/
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about Entity Framework 4.1.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/04/03/entity-framework-4-1-basics-1/">Basics (1)</a> </li> </ul>  <p>In this article, I’ll cover how to over conventions.</p>  <p>We’ve seen that EF 4.1 Code-First infer the mapping between the model (classes) and the tables according to conventions.&#160; When those conventions aren’t to our liking, we have two different ways to override the conventions:</p>  <ul>   <li>Intercept the model builder and modify the model with the fluent API </li>    <li>Add attributes to our class model </li> </ul>  <p>In future release, we’ll also be able to add / remove conventions, but this feature has been removed on 4.1 (it was present in the CTPs).</p>  <p>As a basis for example, I’ll use the following <em>Order</em> class:</p>  <blockquote>   <p>public class Order      <br />{       <br />&#160;&#160;&#160; public int OrderID { get; set; }       <br />&#160;&#160;&#160; public string OrderTitle { get; set; }       <br />&#160;&#160;&#160; public string CustomerName { get; set; }       <br />&#160;&#160;&#160; public DateTime TransactionDate { get; set; }       <br />} </p> </blockquote>  <p>Let’s start with the model builder.&#160; In order to use the model builder, we must override a method on our db-context class:</p>  <blockquote>protected override void OnModelCreating(DbModelBuilder modelBuilder)    <br />{     <br />&#160;&#160;&#160; base.OnModelCreating(modelBuilder);     <br />&#160;&#160;&#160; //&#160;&#160;&#160; Map schemas     <br />&#160;&#160;&#160; modelBuilder.Entity&lt;Order&gt;().ToTable(&quot;efdemo.Order&quot;);     <br />} </blockquote>  <p>By default EF maps an entity to a table having the same name in the database schema <em>dbo</em>.&#160; Here I do map the entity <em>Order</em> to the table <em>efdemo.Order</em>.</p>  <p>The model builder exposes a <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent API</a>.&#160; Basically that means that you can chain most operations on the API because the methods are always returning the same object.&#160; Therefore, we could chain operations like this:</p>  <blockquote>   <p>modelBuilder.Entity&lt;Order&gt;().Property(x =&gt; x.OrderID)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .IsRequired()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasColumnName(&quot;TheOrderID&quot;);</p> </blockquote>  <p>Here we did three things with the property <em>OrderID</em>:</p>  <ul>   <li>Made it an identity column (i.e. auto-incremental column) </li>    <li>Made it required (ie non-nullable) </li>    <li>Mapped it to the column <em>TheOrderID</em> </li> </ul>  <p>Here we can mention one of the powerful feature of EF 4.1:&#160; the way we single out properties.&#160; Instead of using a string to identify the property, we use a lambda expression.&#160; This has several advantages:</p>  <ul>   <li>Intellisense will help you </li>    <li>You’ll have compile-time error-checking </li>    <li>The property type is known and influence what you can do with the property afterwards (for instance, only string property can be min-max length) </li> </ul>  <p>So what would convention would we typically want to override?&#160; Well, if we look at our <em>Order</em> class, by default we would have the following conventions applied that do not suit me:</p>  <ul>   <li>The table will be in the dbo schema </li>    <li><em>OrderID</em> is the primary key but isn’t auto-incremental </li>    <li>All other columns are nullable </li>    <li>The <em>string</em> columns are of length 128 (will be MAX at RTM) </li> </ul>  <p>We can override those convention using the model builder:</p>  <blockquote>   <p>//&#160;&#160;&#160; Map schemas      <br />modelBuilder.Entity&lt;Order&gt;().ToTable(&quot;efdemo.Order&quot;);       <br />//&#160;&#160;&#160; Identity Column       <br />modelBuilder.Entity&lt;Order&gt;().Property(x =&gt; x.OrderID)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);       <br />//&#160;&#160;&#160; String columns       <br />modelBuilder.Entity&lt;Order&gt;().Property(x =&gt; x.OrderTitle)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .IsRequired()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasMaxLength(64);       <br />modelBuilder.Entity&lt;Order&gt;().Property(x =&gt; x.CustomerName)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .IsRequired()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasMaxLength(32);       <br />//&#160;&#160;&#160; Date Columns       <br />modelBuilder.Entity&lt;Order&gt;().Property(x =&gt; x.TransactionDate)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .IsRequired();</p> </blockquote>  <p>This is quite verbose but it has the advantage of leaving the model untouched, purely POCO.</p>  <p>Now, the other way to override conventions is to add attributes to the classes.</p>  <p>This approach is much less verbose and feels more natural since the information about a property are on a property.&#160; The only issue is that your class isn’t POCO anymore, although it isn’t EF either:&#160; the attributes you use to decorate your classes are from <em>System.ComponentModel.DataAnnotations</em>, the .NET validation module, and are therefore not coupled to EF.</p>  <p>Let’s give an example:</p>  <blockquote>   <p>public class Order      <br />{       <br />&#160;&#160;&#160; public int OrderID { get; set; }&#160; <br /></p>    <p>&#160;&#160;&#160; [Required]      <br />&#160;&#160;&#160; [StringLength(32, MinimumLength = 2)] </p>    <p>&#160;&#160;&#160; public string OrderTitle { get; set; }      <br /></p>&#160;&#160;&#160;&#160;&#160; [Required]     <br />&#160;&#160;&#160; [StringLength(64, MinimumLength = 5)]     <p>&#160;&#160;&#160; public string CustomerName { get; set; }      <br /></p>&#160;&#160;&#160;&#160;&#160; [Required]     <br />    <p>&#160;&#160;&#160; public DateTime TransactionDate { get; set; }      <br />} </p> </blockquote>  <p>Here we told the model builder to map <em>OrderTitle</em> to a non-nullable nvarchar of size 32.&#160; The minimum size of 2 isn’t used to create the schema mapping but it will be used for validation.</p>  <p>The example I just gave puts business annotation.&#160; But you could put technical annotations too:</p>  <blockquote>   <p>public class Order      <br />{       <br /></p>    <p>&#160; [Key]      <br />&#160; [DatabaseGenerated(DatabaseGeneratedOption.Identity)]       <br />&#160; public int OrderNumber { get; set; } </p>    <p>&#160;&#160;&#160; …      <br />} </p> </blockquote>  <p>Here we force the <em>OrderNumber</em> property to be the primary key of the table and we also specify that it’s an auto-incremental column.</p>  <p>You can therefore use either <em>OnModelCreated</em> or annotations to override conventions.&#160; Some minor restrictions apply, for instance (the ones I’ve noticed):</p>  <ul>   <li>Table name override isn’t supported with annotations </li>    <li>Minimum length isn’t supported in <em>OnModelCreated</em> </li>    <li>Regular Expression isn’t supported in <em>OnModelCreated</em> </li> </ul>  <p>Those are quite understandable:&#160; <em>OnModelCreated</em> supports only what pertains to table-mapping (reg-ex nor minimum length don’t influence db-schemas) while annotations support mostly validations.</p>  <p>For me the guideline I’m using is:</p>  <ul>   <li>Use annotations to enrich the model with validation rules </li>    <li>Use <em>OnModelCreated</em> to put db-only constraints (key, auto-incremented columns, table-name override, column-type override, etc.) </li> </ul>  <p>This way your model gets richer and remains POCO.&#160; You can reuse your model elsewhere and benefit from the validation rules.</p>