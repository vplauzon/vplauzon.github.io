---
title: 'Entity Framework 4.1: Deep Fetch vs Lazy Load (3)'
date: 2011-04-11 17:47:00 -07:00
permalink: /2011/04/11/entity-framework-4-1-deep-fetch-vs-lazy-load-3/
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about Entity Framework 4.1.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/04/03/entity-framework-4-1-basics-1/">Basics (1)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/06/entity-framework-4-1-override-conventions-2/">Override conventions (2)</a> </li> </ul>  <p>In this article, I’ll cover the control of what is getting loaded in queries.</p>  <p>EF 4.1 is able to manage relations.&#160; Now which relations get loaded when you do a query?&#160; Everyone “visible” to the object?&#160; In some cases that might make sense (e.g. when you query an entity that has only a child entity), but in many cases you would end up load a good portion of the database or at least much more data that you would like.</p>  <p>By default, EF 4.1 loads only the entities in the query, but it supports two features to help you control what is loaded:</p>  <ul>   <li>Deep Fetch </li>    <li>Lazy Load </li> </ul>  <p><strong>----------------------------</strong></p>  <p><strong>UPDATE:&#160; Typically, deep fetch is referred to as “Eager loading”.&#160; Sorry for inventing a term!</strong></p>  <p><strong>----------------------------</strong></p>  <p>I came up with the name deep fetch, I’m not sure there is one for that mechanism.&#160; If there is feel free to tell me.&#160; Anyhow, this mechanism allow you to specify entities you would like to be loaded along the way:</p>  <blockquote>   <p>using (var context = new MyDomainContext())      <br />{       <br /></p>    <p>&#160; var orders = from o in context.Orders.Include(&quot;OrderDetails&quot;)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; where o.CustomerName == &quot;Mac&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select o; </p>    <p>…</p> </blockquote>  <p>Here I specify that I want to load certain orders (the ones with a <em>Mac</em> as customer name) and that I want the order details of those orders to be loaded along the way.</p>  <p>You can actually look at the generated SQL query:</p>  <blockquote>   <p>Console.WriteLine(orders.ToString());</p> </blockquote>  <p>EF 4.1 doesn’t generate easy to read queries and they quickly become impossible to decipher, but this one you should be able to read and you’ll see that the order details are loaded with it.</p>  <p>Now this brings an issue of EF 4.1 in general regarding deep fetch:&#160; query efficiency.&#160; If you give the exercise to a graduate to write a query to retrieve the orders and order details, chances are they’re going to write something functionally equivalent to the generated query.&#160; If you’re lucky they might be smarter and write a query returning two result sets:&#160; one for the orders and one for the details.&#160; This would be much more efficient since you wouldn’t repeat all the order information for each order details.&#160; For some reason EF never supported that.&#160; Probably because it isn’t supported across all database systems and it would be forced to generate two SQL queries for one LINQ query which would probably open a can of worms.&#160; Anyway, keep this in mind as it can easily get ugly on the performance side.</p>  <p>Anyhow, you could request more than one sub collections be brought along:</p>  <blockquote>   <p>var orders = from o in context.Orders.Include(&quot;OrderDetails&quot;).Include(&quot;Businesses&quot;)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; where o.CustomerName == &quot;Mac&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select o; </p> </blockquote>  <p>The other feature you can use to control what’s brought along is lazy loading.&#160; By default, lazy loading is supported.&#160; If you want to disable it, you need to do it explicitly.&#160; The best place would be in the constructor of your db context:</p>  <blockquote>   <p>public MyDomainContext()      <br />{       <br />&#160;&#160;&#160; this.Configuration.LazyLoadingEnabled = false;       <br />} </p> </blockquote>  <p>Now lazy loading works as you would expect:&#160; you request an entity-set, it gets loaded and if you try to access a sub-collection of an entity, it gets loaded on the fly, auto-magically!</p>  <p>How does EF knows you’re trying to access a sub collection?&#160; You collection are POCO collection (e.g. List&lt;EntityType&gt;), so no events are raised if you access them.&#160; Anyone?&#160; It’s generating a dynamic object deriving from your entities and override your sub-collection access properties.&#160; Yes it does.&#160; This is why you need to mark your sub-collection access properties with the keyword virtual in order for the magic to operate:</p>  <blockquote>   <p>public class Order      <br />{       <br />&#160;&#160;&#160; public int OrderID { get; set; }       <br />&#160;&#160;&#160; public string OrderTitle { get; set; }       <br />&#160;&#160;&#160; public string CustomerName { get; set; }       <br />&#160;&#160;&#160; public DateTime TransactionDate { get; set; }       <br />&#160;&#160;&#160; public <strong><font color="#ff0000">virtual </font></strong>List&lt;OrderDetail&gt; OrderDetails { get; set; }       <br />&#160;&#160;&#160; public <strong><font color="#ff0000">virtual</font> </strong>List&lt;Business&gt; Businesses { get; set; }       <br />} </p> </blockquote>  <p>Let’s give some characteristics of the two mechanisms.&#160; For deep fetch:</p>  <ul>   <li>Reduces Latency (it fetches all data in one trip to the DB server) </li>    <li>You need to know in advance what you’re going to need and be explicit about it </li> </ul>  <p>Lazy Loading:</p>  <ul>   <li>Very forgiving, since it will just load the data on requests, you do not need to plan in advance </li>    <li>Could kill performance because of latency (think of a loop on parent entities and lazy load of the children of one parent in the body of the loop) </li> </ul>  <p>Now, when should we use which mechanism?&#160; I’ll give you my guidelines here:&#160; feel free to bring up other ones.&#160; I would use lazy loading except when you have loops with a lazy load in the body of the loop.&#160; It might create 2-3 server queries instead of one, but it is still acceptable, especially given the shortcoming of the deep fetch query mechanism.</p>