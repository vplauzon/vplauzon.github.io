---
title: 'Applied SOA: Part 5 – Interoperability'
date: 2011-12-13 22:04:30 -05:00
permalink: /2011/12/13/applied-soa-part-5-interoperability/
categories:
- Solution
tags:
- API
---
<p>This is part of a series of blog post about Applied SOA. The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/17/applied-soa-part-1-introduction/">Introduction</a> </li>    <li><a title="Preview “Applied SOA- Part 2 – SOA Basics”" href="http://vincentlauzon.wordpress.com/2011/11/27/applied-soa-part-2-soa-basics/">SOA Basics</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/11/29/applied-soa-part-3-service-discovery-process/">Service Discovery Process</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/12/09/applied-soa-part-4-service-taxonomy/">Service Taxonomy</a> </li> </ul>  <p>In this article, I’ll cover the Interoperability.&#160; SOA aims is to expose capabilities through services in order to let different agents leverage those capabilities.&#160; A common theme is therefore interoperability.&#160; Given the universal reach of services (as opposed to objects or components for instance), the interoperability bar tends to be quite high.</p>  <h3>Technical Interoperability</h3>  <p>Now the first thing that pops into technologists’ mind when interoperability is mentioned is technical interoperability:&#160; the ability for two systems to communicate with each other despite their underlying technological stack differences.&#160; This is no small challenges.</p>  <p>Indeed, we would think that with SOAP &amp; WS-*, all those interoperability problems are behind us, all taken care of by standardisation bodies, right?&#160; Well, not quite.&#160; Although those standards enable basic interoperability in an unprecedented way, they still do not guarantee it.&#160; The center of the problem is the way SOAP specs can be interpreted and how differently it was interpreted by different vendors.</p>  <p>As a result, it isn’t trivial to achieve interoperability between heterogeneous systems.&#160; For instance, <a href="http://vincentlauzon.wordpress.com/2011/08/02/wcf-express-interop-bindings/">Microsoft published four months ago</a> a <a href="http://wcf.codeplex.com/wikipage?title=WCF%20Express%20Interop%20Bindings">package of bindings</a> to use with different vendors.</p>  <p>Two opposing forces are at play when we consider technical interoperability:</p>  <ul>   <li>The richness of the protocol used in the services </li>    <li>How interoperable we want it to be </li> </ul>  <p>For instance, consider the following list of Services protocol: </p>  <ul>   <li>WS-* (e.g. WS-Atomic, WS-Security, etc.)</li>    <li>WS-I Basic Profile</li>    <li>REST / OData</li>    <li>SQL Views</li>    <li>File share</li> </ul>  <p>As we go down the list, protocols get simpler and simpler.&#160; The first ones allow rich scenarios (e.g. distributing a transaction, sharing a claims based security context, etc.) while the later ones do not.&#160; The amount of potential clients grow as we go down though:&#160; who&#160; can’t drop a file on a file share?</p>  <p>Now once you’ve decided on how much interoperability you can afford given the protocol your solution needs, you have many tactics to make it happen.&#160; For web services, this typically involves getting closer protocol standards and not letting your development platform do as much as it otherwise would.</p>  <p>Indeed, many web services platform offer a great story to quickly author web services by eliminating a lot of the gory details of SOAP.&#160; Different development platform (e.g. .NET vs Java) takes different decisions on those details which make them incompatible though.&#160; Pesky details such as field ordering, native types to SOAP types mapping, how list of objects are mapped to XML schema, etc. can all bring incompatibilities between a service and its consumers if written in different platforms.</p>  <p>All that being said, those problems are known and great guidelines exist.&#160; For the .NET platform, an excellent tool for authoring interoperable web services is <a href="http://www.thinktecture.com/resourcearchive/tools-and-software/wscf">WSCF</a> (Web Service Contract First) by <a href="http://www.thinktecture.com/">thinktecture</a>.&#160; Those tools accelerate protocol-centric development instead of marking details.</p>  <p>The key here is to test with the different target platforms.&#160; Quite similar to multi-web browser development really.</p>  <h3>Business Interoperability</h3>  <p>Another aspect of interoperability is business interoperability.&#160; Let’s say we solved the technical interoperability problem and we have a great recipe to build web services interoperable with our target consumers but that we do not speak the same business language, how really interoperable are we?</p>  <p>An example I like to give concerns two hypothetical services within a consulting company (yeah, I love consulting company examples!).&#160; The first service returns a list of employees who didn’t fill up their weekly timesheets while a second service sends email to an employee.&#160; We could easily combine those two services in order to warn offenders they haven’t filled their timesheet yet, couldn’t we?&#160; What if the first service signature looks something like this:</p>  <blockquote>   <p>EmployeeData[] GetOffenders()</p> </blockquote>  <p>where the <em>EmployeeData</em> data contract has the following shape:</p>  <blockquote>   <p><font>EmployeeData :</font>       <br /><font>{        <br />&#160; EmployeeNumber : integer,         <br />&#160; FirstName : string,</font>       <br /><font>&#160; LastName : string</font>       <br /><font>}</font></p> </blockquote>  <p>and the second service looks like this:</p>  <blockquote>   <p>SendEmail(emailAddress : string, mailBody : string)</p> </blockquote>  <p>Well…&#160; we got ourselves a typical data mismatch problem.&#160; The first service identify employees by employee number while the second one expect their email address.</p>  <p>A simplistic example, but quite common one in large enterprises, especially ones where acquisitions created a patchwork of different semantics (e.g. here a project is something with a billing code and people staffed on it, there it’s an aggregation of teams with no budget semantics).</p>  <p>Again, this is a problem with solid existing solutions, but it is still something to be mindful of when elaborating a Service Oriented Architecture.&#160; Two typical solutions to this problem are:</p>  <ul>   <li><strong>Schema rationalisation </strong>(or Canonical Data Model, CDM) where services expose a canonical model where different entities only have one meaning and representation.</li>    <li><strong>Entity Aggregation</strong> (e.g. Master Data Management) where different semantics and representations are allowed to exist but a central authority performs reconciliation.</li> </ul>  <p>In conclusion, it is important to define what type of interoperability (both technical &amp; business) we target and to take the necessary steps to achieve it given the challenges of the solution’s context.</p>