---
title:  Expression Trees: Part 1 – Basics
date:  2011-06-08 15:24:00 -04:00
permalink:  "/2011/06/08/expression-trees-part-1-basics/"
categories:
- Solution
tags:
- .NET
---
<p>I’m currently doing an SOA project and I have to put forward the solution architecture for many aspects of the solution.&#160; If you’ve done a bit of true SOA project (not to get into religious debate, let’s just say ‘where your architecture is oriented around services not just as a remote procedure call mechanism but where the services are first class citizen in the system’), you probably faced the problem of different entity representations and mapping between them.</p>  <p>Mapping, in large volume, can be tedious and if you do mapping in both directions, chances are you’ll introduce errors.&#160; A mechanism to reverse mappings would be useful.&#160; Also, when you raise exception or validation errors about a representation, it would be nice to be able to map those directly to another representation.</p>  <p>I knew about expression trees since the introduction of LINQ with C# 3.0.&#160; But since then, there has been some nice features using it in the .NET Framework.&#160; For instance, in ASP.NET MVC, when you do data binding, you don’t say <em>Bind(myObject, “PropertyA”)</em>, you give it an elegant lambda expression, <em>m =&gt; m.PropertyA</em>.&#160; Same for <a href="http://vincentlauzon.wordpress.com/2011/04/21/entity-framework-4-1-series/">Entity Framework 4.1</a> when doing convention overrides.&#160; Those have many advantages:&#160; they are strongly typed, hence both intellisense and the compiler will help you with the property names, it allows the manipulation of the expression (e.g. reversing a mapping) and refactoring will hit it, while a property name stored between quotes isn’t looked at by any refactoring tool.</p>  <p>Expression trees (ET, phoning home or not) are well documented in <a href="http://msdn.microsoft.com/en-us/library/bb397951.aspx">MSDN articles</a>, but those never show you how to really use it.&#160; I’m going to do a series of blog entry doing just that:&#160; exploring scenarios using expression trees.</p>  <p>Basically, I would like to explore topics such as:</p>  <ul>   <li>Fetching properties with ET </li>    <li>Improving declarative fetching (adding null-checks) </li>    <li>Mapping two representations with ET      <ul>       <li>Finding dependencies </li>        <li>Reversing a mapping </li>        <li>Reversing a partial mapping in an existing object </li>     </ul>   </li>    <li>Do all of that with collections &amp; LINQ queries</li>    <li>etc. </li> </ul>  <p>Here’s the first entry where I’ll cover some basics.</p>  <p>First let’s look at lambda expressions.&#160; Lambda expressions are coming&#160; from the functional programming tradition where you can express a function in a very compact way.&#160; In C#, we can view a lambda expression as the result of an evolution of delegates.</p>  <p>In .NET 1.x, when you needed a delegate, you had to implement a separate method:</p>  <blockquote>   <p>private static void DelegateEvolution()      <br />{       <br />&#160;&#160;&#160; IntToInt incrementDelegate = new IntToInt(<strong>Increment</strong>); </p>    <p>&#160;&#160;&#160; Console.WriteLine(incrementDelegate(2));      <br />} </p>    <p>private <font color="#0000ff">delegate</font> int IntToInt(int integer); </p>    <p>private static int Increment(int num)      <br />{       <br />&#160;&#160;&#160; return num + 1;       <br />} </p> </blockquote>  <p>This was quite verbose when you wanted to expose simple functions.&#160; .NET 2.0 brought two improvements:&#160; anonymous delegates and implicit delegate:</p>  <blockquote>   <p>IntToInt incrementDelegate = new IntToInt(Increment);&#160;&#160;&#160; //&#160;&#160;&#160; .NET 1.x      <br />IntToInt incrementDelegate2 = Increment;&#160;&#160;&#160; //&#160;&#160;&#160; .NET 2.0, no need to new the delegate       <br />IntToInt incrementDelegate20 = <strong>delegate(int num)</strong> { return num + 1; };&#160;&#160;&#160; //&#160;&#160;&#160; .NET 2.0 </p> </blockquote>  <p>C# 3.0 brought the lambda expressions:</p>  <blockquote>   <p>IntToInt incrementDelegate3 = num =&gt; num + 1;&#160;&#160;&#160; //&#160;&#160;&#160; .NET 3.0, lambda expression</p> </blockquote>  <p>A lambda expression is simply syntactic sugar to create a delegate.&#160; Underneath, it still is a delegate.&#160; We can prove that to ourselves with the following code:</p>  <blockquote>   <p>IntToInt incrementDelegate3 = num =&gt; num + 1;&#160;&#160;&#160; //&#160;&#160;&#160; .NET 3.0, lambda expression </p>    <p>Console.WriteLine(incrementDelegate3.Method.DeclaringType);      <br />Console.WriteLine(incrementDelegate3.Method.Name); </p> </blockquote>  <p>This will display the class where the delegate is implemented (the class where the lambda expression is defined) and a generated method name, typically containing underscores (‘_’).</p>  <p>Now that was useful for LINQ to objects, but when LINQ to SQL (and later LINQ to Entity) came along, just having a delegate wasn’t enough.&#160; LINQ represents where clauses, projections and other artefacts as lambda expressions.&#160; But in order to translate those expressions into SQL queries, you need more than a delegate, you need a logic representation of the lambda expression where you’ll be able to take it apart and translate it into another language (e.g. TSQL).</p>  <p>Enter the <a href="http://msdn.microsoft.com/en-us/library/bb335710.aspx">expression trees</a>:</p>  <blockquote>   <p>Expression&lt;Func&lt;int, int&gt;&gt; incrementExp = num =&gt; num + 1; </p> </blockquote>  <p>Here, <em>Func&lt;int, int&gt;</em> is a <a href="http://msdn.microsoft.com/en-us/library/bb549151.aspx">.NET Framework defined generic delegate</a>, taking an int, returning an int.&#160; We could take the expression tree and compile it into a delegate.</p>  <blockquote>   <p>Expression&lt;Func&lt;int, int&gt;&gt; incrementExp = num =&gt; num + 1;      <br />Func&lt;int, int&gt; increment = incrementExp.Compile(); </p>    <p>Console.WriteLine(increment(2));      <br />Console.WriteLine(incrementExp); </p> </blockquote>  <p>In the last line, we also print-out the expression tree which lays out the textual representation of it (<em>num =&gt; num+1</em>).</p>  <p>But if we do not compile it, we can look at the inside of the expression tree.&#160; Now this becomes quickly tedious as we’ll see with this very simple one.</p>  <blockquote>   <p>var parameters = incrementExp.Parameters;&#160;&#160;&#160; //&#160;&#160;&#160; Represents the parameters (i.e. num)      <br />var body = incrementExp.Body as BinaryExpression;&#160;&#160;&#160; //&#160;&#160;&#160; Represents num + 1       <br />var bodyNodeType = body.NodeType;&#160;&#160;&#160; //&#160;&#160;&#160; Represents the addition operation       <br />var left = body.Left as ParameterExpression;&#160;&#160;&#160; //&#160;&#160;&#160; Represents 'num'       <br />var right = body.Right as ConstantExpression;&#160;&#160;&#160; //&#160;&#160;&#160; Represents '1' </p>    <p>Console.WriteLine(&quot;Operation:&#160; &quot; + bodyNodeType);      <br />Console.WriteLine(&quot;Left:&#160; &quot; + left.Name);       <br />Console.WriteLine(&quot;Right:&#160; &quot; + right.Value); </p> </blockquote>  <p>We can also create expressions from scratch.&#160; For instance, we could construct a similar lambda with the following code:</p>  <blockquote>   <p>var num = Expression.Variable(typeof(int), &quot;num&quot;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; num variable of type int      <br />var constant = Expression.Constant(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; constant '2'       <br />var addition = Expression.Add(num, constant);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; num + 2       <br />var lambda = Expression.Lambda&lt;Func&lt;int, int&gt;&gt;(addition, num);&#160;&#160;&#160; //&#160;&#160;&#160; num =&gt; num + 2 </p>    <p>Console.WriteLine(lambda);      <br />Console.WriteLine(lambda.Compile()(2)); </p> </blockquote>  <p>This is extremely powerful, because we basically create code semantically but this code is compiled into MSIL and runs as efficiently as any other code you could do in Visual Studio.</p>  <p>Expression trees are read-only:&#160; you can’t modify them.&#160; There is also a mechanism to <a href="http://msdn.microsoft.com/en-us/library/bb546136.aspx">create a modified version</a> though, using the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> (Yes, you’ve read correctly, a GOF pattern is mentioned explicitly in the .NET Fx:&#160; it acknowledges its existence!).</p>  <p>For instance, let’s say we would like to take the lambda <em>num =&gt; num + 1</em> and change it into <em>num =&gt; num + 5</em>.&#160; We first need a <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expressionvisitor.aspx">visitor</a>:</p>  <blockquote>   <p>private class ConstantModifier : ExpressionVisitor      <br />{       <br />&#160;&#160;&#160; protected override Expression VisitConstant(ConstantExpression node)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (node.Value is int &amp;&amp; (int)node.Value == 1)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return Expression.Constant(5);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; else       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return node;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }       <br />&#160;&#160;&#160; }       <br />} </p> </blockquote>  <p>The visitor is creating new expressions if needed otherwise return original expressions.&#160; This visitor only visits constant expressions, but there are virtual methods for each type of expressions.&#160; We can use the visitor to modify an expression tree:</p>  <blockquote>   <p>Expression&lt;Func&lt;int, int&gt;&gt; incrementExp = num =&gt; num + 1;      <br />var modifier = new ConstantModifier();       <br />var modifiedIncrementExp = modifier.Visit(incrementExp) as Expression&lt;Func&lt;int, int&gt;&gt;; </p>    <p>Console.WriteLine(modifiedIncrementExp);      <br />Console.WriteLine(modifiedIncrementExp.Compile()(1)); </p> </blockquote>  <p>So far we’ve looked at lambda expression representing functions computing something at the input and returning an output.&#160; A lambda expression, in .NET, can also represents an <a href="http://msdn.microsoft.com/en-us/library/018hxwa8.aspx">action</a>.&#160; Interestingly enough, there are limitations on how we can express actions when assigning expressions.&#160; For instance, we can’t assign a property within an expression but we can create the expression doing that in code.</p>  <p>Let’s create an expression taking an integer and setting it to the exit code of the application:</p>  <blockquote>   <p>var code = Expression.Variable(typeof(int), &quot;code&quot;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Input      <br />var exitCodeProperty =       <br />&#160;&#160;&#160; Expression.Property(null, typeof(Environment), &quot;ExitCode&quot;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Environment.ExitCode       <br />var assignation = Expression.Assign(exitCodeProperty, code);&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Environment.ExitCode=code       <br />var assignLambda =</p>    <p>&#160;&#160;&#160;&#160;&#160; Expression.Lambda&lt;Action&lt;int&gt;&gt;(assignation, code);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; The action wrapping it </p>    <p>Console.WriteLine(assignLambda);      <br />assignLambda.Compile()(10);       <br />Console.WriteLine(Environment.ExitCode);&#160; </p> </blockquote>  <p>In the next blog entries of this series, I’ll explore specific scenarios.</p>