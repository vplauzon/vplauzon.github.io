---
title:  Expression Trees: Part 2 – Fetching Properties
date:  2011-06-13 21:09:00 -04:00
permalink:  "/2011/06/13/expression-trees-part-2-fetching-properties/"
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about expression trees in .NET 4.0.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/01/expression-trees-part-1-basics/">Basics (1)</a> </li> </ul>  <p>In this article, I’ll cover using Expression Trees (ET) for fetching properties.</p>  <p>In this article, I’ll use the following classes:</p>  <blockquote>   <p>public class Employee      <br />{       <br />&#160;&#160;&#160; public string FirstName { get; set; }       <br />&#160;&#160;&#160; public string LastName { get; set; }       <br />&#160;&#160;&#160; public DateTime DateOfBirth { get; set; }       <br />&#160;&#160;&#160; public Address Address { get; set; }       <br />&#160;&#160;&#160; public Project Project { get; set; }       <br />} </p>    <p>public struct Address      <br />{       <br />&#160;&#160;&#160; public int StreetNumber { get; set; }       <br />&#160;&#160;&#160; public string StreetName { get; set; }       <br />} </p>    <p>public class Project      <br />{       <br />&#160;&#160;&#160; public string ProjectName { get; set; }       <br />&#160;&#160;&#160; public decimal Budget { get; set; }       <br />} </p> </blockquote>  <p>Simply notice that <em>Address</em> is a structure, hence it can’t be <em>null</em>.</p>  <p>First, let’s look at the trivial case:</p>  <blockquote>   <p>Expression&lt;Func&lt;Employee, string&gt;&gt; firstNameExp = e =&gt; e.FirstName;      <br />var firstNameFetcher = firstNameExp.Compile();       <br />var employee = new Employee       <br />{       <br />&#160;&#160;&#160; FirstName = &quot;John&quot;,       <br />&#160;&#160;&#160; LastName = &quot;Smith&quot;,       <br />&#160;&#160;&#160; DateOfBirth = DateTime.Now       <br />}; </p>    <p>Console.WriteLine(firstNameFetcher(employee)); </p> </blockquote>  <p>Here <em>firstNameExp</em> represents an expression tree taking an employee and fetching its first name.&#160; We can compile it and extract a property from an instance of an employee.&#160; Trivial indeed.</p>  <p>The last example uses an expression tree as a delegate.&#160; But an expression tree is much more expressive than a delegate:&#160; it allows use to look inside the code composing it.&#160; Let’s take a similar property fetching expression tree and extract the property path (the name of each property traversed) from it.</p>  <p>This will require a few methods to deliver.&#160; At the heart of this functionality, we need to enumerate the property accessed by the expression.&#160; For this, I can’t simply use a LINQ query since the expression tree is…&#160; a tree, not a list, so it stores its elements by recursive composition.&#160; Instead, I choose to leverage the powerful <a href="http://msdn.microsoft.com/en-us/library/9k7k7cf0(VS.80).aspx">C# yield construct</a>:</p>  <blockquote>   <p>private static IEnumerable&lt;MemberExpression&gt; GetMemberExpressions(Expression e)      <br />{       <br />&#160;&#160;&#160; MemberExpression memberExpression; </p>    <p>&#160;&#160;&#160; while ((memberExpression = e as MemberExpression) != null)      <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; yield return memberExpression; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; e = memberExpression.Expression;      <br />&#160;&#160;&#160; }       <br />} </p> </blockquote>  <p>This method returns an enumeration of <em>MemberExpression</em>.&#160; It returns them from right to left if we consider how the expression is written.&#160; For instance, for <em>m.p1.p2.p3</em>, <em>GetMemberExpressions</em> would return <em>{(m.p1.p2).p3, (m.p1).p2, (m).p1}</em>.&#160; So we now need a method to reverse this enumeration and pull out the property names.&#160; Here we can use LINQ and we gladly do:</p>  <blockquote>   <p>private static string PathFinder(LambdaExpression e)      <br />{       <br />&#160;&#160;&#160; var expressions = GetMemberExpressions(e.Body);       <br />&#160;&#160;&#160; var pathParts = from memberExp in expressions.Reverse()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select memberExp.Member.Name;       <br />&#160;&#160;&#160; var path = string.Join(&quot;.&quot;, pathParts); </p>    <p>&#160;&#160;&#160; return path;      <br />} </p> </blockquote>  <p>We can now use this method to introspect lambda expressions:</p>  <blockquote>   <p>Expression&lt;Func&lt;Employee, string&gt;&gt; firstNameExp = e =&gt; e.FirstName;      <br />Expression&lt;Func&lt;Employee, int&gt;&gt; streetNumberExp = e =&gt; e.Address.StreetNumber;       <br />Expression&lt;Func&lt;Employee, string&gt;&gt; projectNameExp = e =&gt; e.Project.ProjectName; </p>    <p>Console.WriteLine(PathFinder(firstNameExp));      <br />Console.WriteLine(PathFinder(streetNumberExp));       <br />Console.WriteLine(PathFinder(projectNameExp)); </p> </blockquote>  <p>This code displays, unsurprisingly:</p>  <ul>   <li>FirstName </li>    <li>Address.StreetNumber </li>    <li>Project.ProjectName </li> </ul>  <p>What we just did is to look inside an expression tree to extract information from it.&#160; We can also modify this expression tree.&#160; An interesting example would be to harden a property fetch.&#160; Here, by harden, I mean checking for null values.&#160; For instance, if I provide the lambda expression:</p>  <blockquote>   <p>m =&gt; m.p1.p2</p> </blockquote>  <p>I would like to automatically generate the following:</p>  <blockquote>   <p>m =&gt; m!=null ? (m.p1!=null ? m.p1.p2 : null) : null;</p> </blockquote>  <p>The difference between the former an the latter is that the former will throw an exception if <em>m</em> or <em>m.p1</em> is <em>null</em> while the latter simply returns <em>null</em>, hence hardening it.&#160; There might be different way to do it, you might not want to return <em>null</em> but instead be informed that it’s impossible to fetch the property for instance.&#160; All cases would go about similar ways to be implemented.</p>  <p>The simplest way to implement this transformation is to use the visitor pattern we discussed in the previous post:</p>  <blockquote>   <p>private class SafeMemberAccessVisitor : ExpressionVisitor      <br />{       <br />&#160;&#160;&#160; protected override Expression VisitMember(MemberExpression node)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Only relevant if we are trying to access       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; a member from a class (nullable)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (node.Member.DeclaringType.IsClass)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {&#160;&#160;&#160; //&#160;&#160;&#160; We harden the expression we're about to fetch a member from       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var safeSubExpression = Visit(node.Expression);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Represents the e != null expression       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var test = Expression.NotEqual(       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; safeSubExpression,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression.Constant(null));       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Represents the e!=null ? e.p : null expression       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var inlineIf = Expression.Condition(       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; test,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; node,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression.Default(node.Type)); </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return inlineIf;      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; We rely on base implementation otherwise      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return base.VisitMember(node);       <br />&#160;&#160;&#160; }       <br />}&#160; </p> </blockquote>  <p>Here we let the visitor base class navigate the expression tree recursively and find the member-access expressions for us.</p>  <p>Using the visitor is simple enough:</p>  <blockquote>   <p>private static Expression&lt;Func&lt;M, R&gt;&gt; MakeSafe&lt;M, R&gt;(Expression&lt;Func&lt;M, R&gt;&gt; unsafeExp)      <br />{       <br />&#160;&#160;&#160; var visitor = new SafeMemberAccessVisitor();       <br />&#160;&#160;&#160; var modifiedIncrementExp = visitor.Visit(unsafeExp) as Expression&lt;Func&lt;M, R&gt;&gt;; </p>    <p>&#160;&#160;&#160; return modifiedIncrementExp;      <br />} </p> </blockquote>  <p>We can then use this method:</p>  <blockquote>   <p>var firstNameExp = MakeSafe((Employee e) =&gt; e.FirstName);      <br />var streetNumberExp = MakeSafe((Employee e) =&gt; e.Address.StreetNumber);       <br />var projectNameExp = MakeSafe((Employee e) =&gt; e.Project.ProjectName); </p>    <p>Console.WriteLine(firstNameExp);      <br />Console.WriteLine(streetNumberExp);       <br />Console.WriteLine(projectNameExp); </p> </blockquote>  <p><em>Expression.ToString</em> returns a Visual Basic representation of an expression, so we get:</p>  <ul>   <li>e =&gt; IIF((e != null), e.FirstName, default(String))</li>    <li>e =&gt; IIF((e != null), e.Address, default(Address)).StreetNumber</li>    <li>e =&gt; IIF((IIF((e != null), e.Project, default(Project)) != null), e.Project.ProjectName, default(String))</li> </ul>  <p>Those are correct.&#160; We are using default values for types as oppose to <em>null</em>.&#160; Default was introduced in .NET 2.0 to handle generics.&#160; A reference type default value is <em>null</em> while a value type has a specific default value (e.g. for integers, <em>0</em>).</p>  <p>We can use those hardened expression trees on real cases.&#160; We first create an instance of employee and compile the expression trees into delegates:</p>  <blockquote>   <p>var employee = new Employee     <br />{      <br />&#160;&#160;&#160; FirstName = &quot;John&quot;,      <br />&#160;&#160;&#160; LastName = &quot;Smith&quot;,      <br />&#160;&#160;&#160; DateOfBirth = DateTime.Now,      <br />&#160;&#160;&#160; Address = new Address { StreetName = &quot;Baker Street&quot;, StreetNumber = 222 },      <br />&#160;&#160;&#160; Project = new Project { Budget = 6000, ProjectName = &quot;POC&quot; }      <br />};      <br />var firstNameFetcher = firstNameExp.Compile();      <br />var streetNumberFetcher = streetNumberExp.Compile();      <br />var projectNameFetcher = projectNameExp.Compile(); </p> </blockquote>  <p>Then we can test the delegate in different scenarios:</p>  <blockquote>   <p>Console.WriteLine(firstNameFetcher(employee));&#160; //&#160; John     <br />Console.WriteLine(streetNumberFetcher(employee));&#160; //&#160; 222      <br />Console.WriteLine(projectNameFetcher(employee));&#160;&#160; //&#160; POC</p>    <p>Console.WriteLine(projectNameFetcher(null));&#160; //&#160; null     <br />Console.WriteLine(streetNumberFetcher(null));&#160; // 0      <br />employee.Project = null;      <br />Console.WriteLine(projectNameFetcher(employee));&#160; //&#160; null      <br />Console.WriteLine(projectNameFetcher(null));&#160;&#160; //&#160; null</p> </blockquote> This really shows the power of expression trees.&#160; A consumer can <em>describe</em> an intent with code and we can manipulate that intent into real compiled code on the fly.