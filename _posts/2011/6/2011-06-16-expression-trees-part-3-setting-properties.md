---
title:  Expression Trees: Part 3 – Setting Properties
date:  2011-06-17 00:09:00 +00:00
permalink:  "/2011/06/16/expression-trees-part-3-setting-properties/"
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about expression trees in .NET 4.0.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/01/expression-trees-part-1-basics/">Basics (1)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/06/13/expression-trees-part-2-fetching-properties/">Fetching Properties (2)</a>&#160; </li> </ul>  <p>In this article, I’ll cover using Expression Trees (ET) for setting properties.</p>  <p>I’ll use the same object model I’ve used in the <a href="http://vincentlauzon.wordpress.com/2011/06/13/expression-trees-part-2-fetching-properties/">last article</a> for examples:</p>  <blockquote>   <p>public class Employee      <br />{       <br />&#160;&#160;&#160; public string FirstName { get; set; }       <br />&#160;&#160;&#160; public string LastName { get; set; }       <br />&#160;&#160;&#160; public DateTime DateOfBirth { get; set; }       <br />&#160;&#160;&#160; public Address Address { get; set; }       <br />&#160;&#160;&#160; public Project Project { get; set; }       <br />} </p>    <p>public struct Address      <br />{       <br />&#160;&#160;&#160; public int StreetNumber { get; set; }       <br />&#160;&#160;&#160; public string StreetName { get; set; }       <br />} </p>    <p>public class Project      <br />{       <br />&#160;&#160;&#160; public string ProjectName { get; set; }       <br />&#160;&#160;&#160; public decimal Budget { get; set; }       <br />} </p> </blockquote>  <p>Let’s show something quite powerful, although surprisingly simple to implement:&#160; transforming a fetching (get) expression into a setter.</p>  <p>Basically, we want to implement the following method:</p>  <blockquote>   <p>private static Expression&lt;Action&lt;M, R&gt;&gt; MakeSet&lt;M, R&gt;(Expression&lt;Func&lt;M, R&gt;&gt; fetcherExp) </p> </blockquote>  <p>That is, we want to take an expression taking an object of type <em>M</em> and returning an object of type <em>R</em> by fetching a property (or property path) on object <em>M</em> and transform it into an action able to take an object of type <em>M</em> and set the same property value.</p>  <p>As mentioned, this is surprisingly straightforward.&#160; The first thing to realize is that even if we have a long property path (e.g. <em>m.p1.p2.p3.p4.p5</em>), we only need to turn the last getter into a setter.</p>  <blockquote>   <p>private static Expression&lt;Action&lt;M, R&gt;&gt; MakeSet&lt;M, R&gt;(Expression&lt;Func&lt;M, R&gt;&gt; fetcherExp)      <br />{       <br />&#160;&#160;&#160; if (fetcherExp.Body.NodeType != ExpressionType.MemberAccess)       <br />&#160;&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentException(       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;This should be a member getter&quot;,       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;fetcherExp&quot;);       <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; //&#160;&#160;&#160; Input model      <br />&#160;&#160;&#160; var model = fetcherExp.Parameters[0];       <br />&#160;&#160;&#160; //&#160;&#160;&#160; Input value to set       <br />&#160;&#160;&#160; var value = Expression.Variable(typeof(R), &quot;v&quot;);       <br />&#160;&#160;&#160; //&#160;&#160;&#160; Member access       <br />&#160;&#160;&#160; var member = fetcherExp.Body;       <br />&#160;&#160;&#160; //&#160;&#160;&#160; We turn the access into an assignation to the input value       <br />&#160;&#160;&#160; var assignation = Expression.Assign(member, value);       <br />&#160;&#160;&#160; //&#160;&#160;&#160; We wrap the action into a lambda expression with parameters       <br />&#160;&#160;&#160; var assignLambda = Expression.Lambda&lt;Action&lt;M, R&gt;&gt;(assignation, model, value); </p>    <p>&#160;&#160;&#160; return assignLambda;      <br />}</p> </blockquote>  <p>And voilà!&#160; If you want to see the results, simply print-out the resulting expressions:</p>  <blockquote>   <p>var lastNameExp = MakeSet((Employee e) =&gt; e.LastName);      <br />var streetNameExp = MakeSet((Employee e) =&gt; e.Address.StreetName);       <br />var projectBudgetExp = MakeSet((Employee e) =&gt; e.Project.Budget); </p>    <p>Console.WriteLine(lastNameExp);      <br />Console.WriteLine(streetNameExp);       <br />Console.WriteLine(projectBudgetExp); </p> </blockquote>  <p>As expected, this prints out:</p>  <ul>   <li>(e, v) =&gt; (e.LastName = v) </li>    <li>(e, v) =&gt; (e.Address.StreetName = v) </li>    <li>(e, v) =&gt; (e.Project.Budget = v) </li> </ul>  <p>You can even run them.&#160; First, create an instance of an object and compile the expressions into delegates:</p>  <blockquote>   <p>var lastNameSetter = lastNameExp.Compile();      <br />var streetNameSetter = streetNameExp.Compile();       <br />var projectBudgetSetter = projectBudgetExp.Compile(); </p>    <p>var employee = new Employee      <br />{       <br />&#160;&#160;&#160; FirstName = &quot;John&quot;,       <br />&#160;&#160;&#160; LastName = &quot;Smith&quot;,       <br />&#160;&#160;&#160; DateOfBirth = DateTime.Now,       <br />&#160;&#160;&#160; Address = new Address { StreetName = &quot;Baker Street&quot;, StreetNumber = 222 },       <br />&#160;&#160;&#160; Project = new Project { Budget = 6000, ProjectName = &quot;POC&quot; }       <br />}; </p> </blockquote>  <p>Then try it out:</p>  <blockquote>   <p>lastNameSetter(employee, &quot;Bob&quot;);      <br />Console.WriteLine(employee.LastName);       <br />streetNameSetter(employee, &quot;Sainte-Catherine&quot;);       <br />Console.WriteLine(employee.Address.StreetName);       <br />projectBudgetSetter(employee, 54);       <br />Console.WriteLine(employee.Project.Budget); </p> </blockquote>  <p>This last code snippet outputs:</p>  <ul>   <li>Bob </li>    <li>Baker Street </li>    <li>54 </li> </ul>  <p>This is all as expected, except maybe for the second one.&#160; Why didn’t the new street name (i.e. Sainte-Catherine) stuck on the employee’s address?</p>  <p>Well, that’s because <em>Address</em> is a struct, hence a value type, hence, when you do something like <em>e.Address</em>, what you get is a copied value.&#160; Therefore, if you change your copy, you don’t change the original, as we did here.</p>