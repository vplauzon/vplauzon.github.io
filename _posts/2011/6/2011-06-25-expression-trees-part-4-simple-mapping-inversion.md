---
title: 'Expression Trees: Part 4 – Simple mapping inversion'
date: 2011-06-25 18:39:00 -04:00
permalink: /2011/06/25/expression-trees-part-4-simple-mapping-inversion/
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about expression trees in .NET 4.0.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/06/01/expression-trees-part-1-basics/">Basics (1)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/06/13/expression-trees-part-2-fetching-properties/">Fetching Properties (2)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/06/16/expression-trees-part-3-setting-properties/">Setting Properties (3)</a> </li> </ul>  <p>In this article, I’ll cover simple mapping inversion using Expression Trees (ET).&#160; By simple I mean that we’ll map two objects properties / fields directly:&#160; there won’t be any complex properties.</p>  <p>Let’s say we have the following two classes:</p>  <blockquote>   <p>public class Individual      <br />{       <br />&#160;&#160;&#160; public string FirstName { get; set; }       <br />&#160;&#160;&#160; public string LastName { get; set; }       <br />&#160;&#160;&#160; public DateTime DateOfBirth { get; set; }       <br />&#160;&#160;&#160; public decimal Salary { get; set; }       <br />} </p>    <p>public class PersonTable      <br />{       <br />&#160;&#160;&#160; public string FIRST_NAME { get; set; }       <br />&#160;&#160;&#160; public string LAST_NAME { get; set; }       <br />&#160;&#160;&#160; public DateTime DATE_OF_BIRTH { get; set; }       <br />&#160;&#160;&#160; public decimal SALARY { get; set; }       <br />} </p> </blockquote>  <p>We can easily map one class to the other:</p>  <blockquote>   <p>Expression&lt;Func&lt;PersonTable, Individual&gt;&gt; map = p =&gt; new Individual      <br />{       <br />&#160;&#160;&#160; FirstName = p.FIRST_NAME,       <br />&#160;&#160;&#160; LastName = p.LAST_NAME,       <br />&#160;&#160;&#160; DateOfBirth = p.DATE_OF_BIRTH,       <br />&#160;&#160;&#160; Salary = p.SALARY       <br />};</p> </blockquote>  <p>This expression maps a <em>PersonTable</em> object to an <em>Individual</em> object.&#160; What we would like to do is revert this mapping in order to get a mapping from <em>Individual</em> object to an <em>PersonTable</em> object.</p>  <p>The first thing we would like to do is to extract the different field / property maps:</p>  <blockquote>   <p>private static IEnumerable&lt;Tuple&lt;MemberInfo, MemberInfo&gt;&gt;     <br />&#160;&#160;&#160; ExtractMemberMaps&lt;S, D&gt;(Expression&lt;Func&lt;S, D&gt;&gt; map)      <br />{&#160;&#160;&#160; //&#160;&#160;&#160; Validate the map isn't a null reference      <br />&#160;&#160;&#160; if (map == null)      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentNullException(&quot;map&quot;);      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; var initExp = map.Body as MemberInitExpression; </p>    <p>&#160;&#160;&#160; //&#160;&#160;&#160; Validate the body of the expression constist in a     <br />&#160;&#160;&#160; //&#160;&#160;&#160; member initialization with a default (no arguments) constructor      <br />&#160;&#160;&#160; if (initExp == null || (initExp.NewExpression.Arguments.Count != 0))      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ApplicationException(&quot;Not a member init expression with empty constructor&quot;);      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; var mappingPairs =     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; from binding in initExp.Bindings.OfType&lt;MemberAssignment&gt;()      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; let memberAssignment = binding.Expression as MemberExpression      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Make sure we have an assignment      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; where memberAssignment != null      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Make sure we assign to a property or a field      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; &amp;&amp; (memberAssignment.Member.MemberType == MemberTypes.Property      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; || memberAssignment.Member.MemberType == MemberTypes.Field)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; select new Tuple&lt;MemberInfo, MemberInfo&gt;(memberAssignment.Member, binding.Member); </p>    <p>&#160;&#160;&#160; //&#160;&#160;&#160; Materialize the enumeration so that it doesn't get recomputed many times     <br />&#160;&#160;&#160; return mappingPairs.ToList();      <br />} </p> </blockquote>  <p>We can then check for each property in the source object where it maps to:</p>  <blockquote>   <p>Expression&lt;Func&lt;PersonTable, Individual&gt;&gt; map = p =&gt; new Individual     <br />{      <br />&#160;&#160;&#160; FirstName = p.FIRST_NAME,      <br />&#160;&#160;&#160; LastName = p.LAST_NAME,      <br />&#160;&#160;&#160; DateOfBirth = p.DATE_OF_BIRTH,      <br />&#160;&#160;&#160; Salary = p.SALARY      <br />}; </p>    <p>var sourceToDestinationMaps = ExtractMemberMaps(map); </p>    <p>Console.WriteLine(MapMember&lt;PersonTable, string&gt;(sourceToDestinationMaps, p =&gt; p.FIRST_NAME));     <br />Console.WriteLine(MapMember&lt;PersonTable, string&gt;(sourceToDestinationMaps, p =&gt; p.LAST_NAME));      <br />Console.WriteLine(MapMember&lt;PersonTable, DateTime&gt;(sourceToDestinationMaps, p =&gt; p.DATE_OF_BIRTH));      <br />Console.WriteLine(MapMember&lt;PersonTable, decimal&gt;(sourceToDestinationMaps, p =&gt; p.SALARY)); </p> </blockquote>  <p>This outputs:</p>  <ul>   <li>System.String FirstName</li>    <li>System.String LastName</li>    <li>System.DateTime DateOfBirth</li>    <li>System.Decimal Salary</li> </ul>  <p>So we do have individual member element maps.&#160; We now have to revert those maps and validate there are no duplicates:</p>  <blockquote>   <p>private static IEnumerable&lt;Tuple&lt;MemberInfo, MemberInfo&gt;&gt;     <br />&#160;&#160;&#160; InvertMaps(IEnumerable&lt;Tuple&lt;MemberInfo, MemberInfo&gt;&gt; maps)      <br />{&#160;&#160;&#160; //&#160;&#160;&#160; Inverts      <br />&#160;&#160;&#160; var invertedMaps =      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; (from map in maps      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select new Tuple&lt;MemberInfo, MemberInfo&gt;(map.Item2, map.Item1)).ToList(); </p>    <p>&#160;&#160;&#160; //&#160;&#160;&#160; Validate uniqueness of mapping     <br />&#160;&#160;&#160; var count = (from map in invertedMaps      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select map.Item1).Distinct().Count(); </p>    <p>&#160;&#160;&#160; if (invertedMaps.Count != count)     <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ApplicationException(string.Format(      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;There are {0} duplicate of destinations&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; invertedMaps.Count - count));      <br />&#160;&#160;&#160; } </p>    <p>&#160;&#160;&#160; return invertedMaps;     <br />} </p> </blockquote>  <p>The only way we could fail the validation is if we had some destination members mapping to the same source member, for instance:</p>  <blockquote>   <p>Expression&lt;Func&lt;PersonTable, Individual&gt;&gt; map = p =&gt; new Individual     <br />{      <br />&#160;&#160;&#160; FirstName = <font color="#0000ff">p.FIRST_NAME</font>,      <br />&#160;&#160;&#160; LastName = <font color="#0000ff">p.FIRST_NAME</font>      <br />}; </p> </blockquote>  <p>Of course that type of mapping would be invalid for inversion since we wouldn’t be able to determine how to map from p.FIRST_NAME.</p>  <p>We can now revert an entire mapping by simply constructing the inverse map:</p>  <blockquote>   <p>private static Expression&lt;Func&lt;D, S&gt;&gt; InvertMapping&lt;S, D&gt;(Expression&lt;Func&lt;S, D&gt;&gt; map)     <br />{&#160;&#160;&#160; //&#160;&#160;&#160; Fetch the maps of each field / property      <br />&#160;&#160;&#160; var sourceToDestMaps = ExtractMemberMaps(map);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Invert the maps      <br />&#160;&#160;&#160; var destToSourceMaps = InvertMaps(sourceToDestMaps);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Creates a variable for the destination type      <br />&#160;&#160;&#160; var destVar = Expression.Variable(typeof(D), &quot;d&quot;);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; New the source type, i.e. new S()      <br />&#160;&#160;&#160; var newSource = Expression.New(typeof(S));      <br />&#160;&#160;&#160; //&#160;&#160;&#160; List the bindings i.e. p1 = m.P1      <br />&#160;&#160;&#160; var bindings = from m in destToSourceMaps      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; let destinationMember = m.Item1      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; let sourceMember = m.Item2      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; let assignation = Expression.MakeMemberAccess(destVar, destinationMember)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select Expression.Bind(sourceMember, assignation);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Init expression, i.e. new S{p1=m.P1,p2=m.P2}      <br />&#160;&#160;&#160; var initSource = Expression.MemberInit(newSource, bindings);      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Creates the lambda expression, i.e. m =&gt; new S{p1=m.P1,p2=m.P2}      <br />&#160;&#160;&#160; var initLambda = Expression.Lambda&lt;Func&lt;D, S&gt;&gt;(initSource, destVar); </p>    <p>&#160;&#160;&#160; return initLambda;     <br />} </p>    <p></p> </blockquote>  <p>Putting it all together:</p>  <blockquote>   <p>Expression&lt;Func&lt;PersonTable, Individual&gt;&gt; map = p =&gt; new Individual     <br />{      <br />&#160;&#160;&#160; FirstName = p.FIRST_NAME,      <br />&#160;&#160;&#160; LastName = p.LAST_NAME,      <br />&#160;&#160;&#160; DateOfBirth = p.DATE_OF_BIRTH,      <br />&#160;&#160;&#160; Salary = p.SALARY      <br />};      <br />var invertMap = InvertMapping(map);      <br />var mapDel = map.Compile();      <br />var invertMapDel = invertMap.Compile();      <br />var person = new PersonTable      <br />{      <br />&#160;&#160;&#160; FIRST_NAME = &quot;John&quot;,      <br />&#160;&#160;&#160; LAST_NAME = &quot;Doe&quot;,      <br />&#160;&#160;&#160; DATE_OF_BIRTH = DateTime.Now.Subtract(TimeSpan.FromDays(100000)),      <br />&#160;&#160;&#160; SALARY = 25000      <br />};      <br />//&#160;&#160;&#160; Map from PersonTable to Individual      <br />var mapped = mapDel(person);      <br />//&#160;&#160;&#160; Map from Individual back to PersonTable      <br />var unmapped = invertMapDel(mapped); </p>    <p>Console.WriteLine(invertMap); </p> </blockquote>  <p>Here we successfully mapped the object from <em>PersonTable </em>to <em>Individual</em> back to <em>PersonTable</em> representation.</p>  <p>The outputted invert map is:</p>  <blockquote>   <p>d =&gt; new PersonTable()</p>    <p>{     <br />&#160; FIRST_NAME = d.FirstName,      <br />&#160; LAST_NAME = d.LastName,      <br />&#160; DATE_OF_BIRTH = d.DateOfBirth,      <br />&#160; SALARY = d.Salary      <br />}</p> </blockquote>  <p>We therefore have something pretty powerful here:&#160; we enter a mapping expression and get the functioning reverse mapping.&#160; This gets quite some of the declarative strength of expression trees.</p>