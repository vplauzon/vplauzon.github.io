---
title: Globalization and web services
date: 2011-01-17 06:44:00 -05:00
permalink: /2011/01/17/globalization-and-web-services/
categories:
- Solution
tags:
- API
---
<p>I always found that globalization is the poor child of computer literature.&#160; In any .NET book, you won’t hear specifically about globalization before chapter 23.&#160; You can even tell it’s not shooting high on the radar when you look at the ways globalization was implemented in the three main front-end Frameworks of .NET:&#160; WinForm (great!), ASP.NET (retrofitted in sub-optimal way in .NET 2.0) &amp; WPF (totally Byzantine and not even in line with the rest of .NET Framework).</p>  <p><img style="display:inline;margin-left:0;margin-right:0;" align="left" src="http://www.wornham.com/img/globalization.jpg" width="240" height="239" />Since I work in Montreal --a bilingual city in a bilingual country-- I’m confronted to globalization on nearly every projects I’m involved in.&#160; So with time you do build up your bag of tricks &amp; patterns around globalization.</p>  <p>I <a href="http://vincentlauzon.wordpress.com/2010/12/31/globalization-patterns-in-wcf-ws-i18n-implementation/">recently posted a blog</a> talking about the W3C globalization specs for SOAP endpoints, <a title="WS-I18N" href="http://www.w3.org/TR/2005/WD-ws-i18n-20050914/">WS-I18N</a>.&#160; I found that spec quite interesting because it describes a standard way to handle globalization at a web service level.</p>  <p>Actually, the most common approach I’ve seen (or architected myself) with globalization &amp; web services is to not localize it.&#160; For the time zone, you can usually get away by returning time in standard GMT and let the client localize it.&#160; For languages, if your application is only bilingual (as is often the case in Canada), you can get away by returning the localized data in both languages since you will typically have properties such as <em>FrenchTitle</em> &amp; <em>EnglishTitle</em> in your data contracts.</p>  <p>This approach has a lot of advantages.&#160; First is simplicity of course.&#160; But you also get other advantages.&#160; For instance, if your application needs to flick between languages in a real-time fashion, with this approach you do not need to interrogate web services again (and potentially get different data, which would make the change language feature a refresh feature at the same time, which is weird).&#160; It’s also easier to implement caching if you do not have out-of-band parameters also.</p>  <p>Sometimes you won’t have that luxury.&#160; For instance, the project I’m currently working on is multi-lingual in the sense the number of supported cultures is open.&#160; We therefore have to model our database with localized value in a vertical way (one row per culture).&#160; For the services we were still lucky.&#160; The only localized values are list of values (lookups) ; for those we manage them explicitly in the respective service.&#160; The other services aren’t localized:&#160; the content is in the language the user punched it in.&#160; Also, we raise SOAP faults with English-message.&#160; The architecture guideline there is that the services aren’t producing user-messages, they are APIs, they can raise faults, but it’s up to the application to interpret the fault and inform the user accordingly.</p> I think it’s important to think about the role of your services in your application, system, enterprise or context in general.&#160; If it’s an API for smart applications to use, I would really aim at not localizing them.&#160; This way you can rip the benefit of simplicity but also, you won’t get into confusion of an application being in culture X calling services in culture Y.&#160; If your services are meant to be use by themselves or by thin applications (e.g. something doing an xslt-transform on the data returned by your services), you should manage the culture at the service layer.