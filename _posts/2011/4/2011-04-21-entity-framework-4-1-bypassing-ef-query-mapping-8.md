---
title:  Entity Framework 4.1: Bypassing EF query mapping (8)
date:  2011-04-21 20:03:00 -04:00
permalink:  "/2011/04/21/entity-framework-4-1-bypassing-ef-query-mapping-8/"
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about Entity Framework 4.1.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/04/03/entity-framework-4-1-basics-1/">Basics (1)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/06/entity-framework-4-1-override-conventions-2/">Override conventions (2)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/11/entity-framework-4-1-deep-fetch-vs-lazy-load-3/">Deep Fetch vs Lazy Load (3)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/13/entity-framework-4-1-complex-types-4/">Complex Types (4)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/15/entity-framework-4-1-many-to-many-relationships-5/">Many to Many Relationships (5)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/17/entity-framework-4-1-optimistic-concurrency-6/">Optimistic Concurrency (6)</a> </li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/19/entity-framework-4-1-inheritance-7/">Inheritance (7)</a> </li> </ul>  <p>In this final article, I’ll cover some ways to bypass EF query mapping.</p>  <p>As all good framework, EF recognize it’s not perfect and won’t ever cover all the angles and it does support opening to the underlying Framework, ADO.NET, by allowing you to call the database directly.</p>  <p>There are three (3) APIs opening the hood to ad-hoc:</p>  <ul>   <li>DbContext.Database.ExecuteSqlCommand </li>    <li>DbContext.Database.SqlQuery </li>    <li>DbSet.SqlQuery </li> </ul>  <p>The first API isn’t very interesting, as it looks identical to its <a href="http://msdn.microsoft.com/en-us/library/system.data.common.dbcommand.aspx">ADO.NET counterpart</a>:</p>  <blockquote>   <p>public int ExecuteSqlCommand(string sql, params object[] parameters); </p> </blockquote>  <p>The second one is more interesting:</p>  <blockquote>   <p>public IEnumerable&lt;TElement&gt; SqlQuery&lt;TElement&gt;(string sql, params object[] parameters); </p> </blockquote>  <p>We can use this method to send SQL command (either a stored procedure call or ad-hoc SQL) directly to the database.&#160; It delivers a little more than ADO.NET in that it’s able to convert the data-readers directly in entities.</p>  <p><em>TElement</em> could be any class.&#160; An important characteristic is that EF doesn’t track returned object, <strong>even if they are entity types</strong>.&#160; This contrasts with the third API, part of <em>DbSet</em>, which tracks returned objects.</p>  <p>Let’s try <em>DbContext.Database.SqlQuery</em>:</p>  <blockquote>   <p>public IEnumerable&lt;SprocReport&gt; GetEntityList()      <br />{       <br />&#160;&#160;&#160; return Database.SqlQuery&lt;SprocReport&gt;(&quot;SELECT LegalEntityBaseID, EntityName FROM dbo.LegalEntity&quot;);       <br />} </p> </blockquote>  <p>It’s good practice to encapsulate those calls inside the DbContext derived class.&#160; Here the class we use is <em>SprocReport</em>:</p>  <blockquote>   <p>public class SprocReport      <br />{       <br />&#160;&#160;&#160; public int LegalEntityBaseID { get; set; }       <br />&#160;&#160;&#160; public string EntityName { get; set; }       <br />} </p> </blockquote>  <p>This class isn’t an entity and its property are mapped directly:&#160; <strong>you have no control on the mapping</strong>.&#160; Even if you use a complex type and override some mapping, those overrides won’t be honoured.</p>  <p>Now if you use <em>DbSet.SqlQuery</em>, the returned entities will be tracked by the change tracker and therefore, if you make modifications to those entities, they will be caught when <em>DbContext.SaveChanges</em> is called.&#160; On the other hand, no column mapping overrides would be honoured there either.</p>  <p>Another way we could bypass EF query-mapping management would be by querying the store using Entity SQL.&#160; Remember the Entity Framework maps an entity model to a physical model and LINQ queries are transformed in queries to the entity model (using eSQL syntax) before being transformed to native queries to the underlying data store (e.g. TSQL).</p>  <p>For instance, we could create an entity set without exposing it:</p>  <blockquote>   <p>protected override void OnModelCreating(DbModelBuilder modelBuilder)      <br />{       <br />&#160;&#160;&#160; base.OnModelCreating(modelBuilder); </p>    <p>&#160;&#160;&#160; modelBuilder.Entity&lt;SimpleEntry&gt;().<font color="#ff0000"><strong>HasEntitySetName</strong></font>(&quot;MyEntry&quot;);       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;SimpleEntry&gt;().ToTable(&quot;MyEntry&quot;, &quot;man&quot;);       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;SimpleEntry&gt;()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Property(s =&gt; s.ID)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasColumnName(&quot;SimpleEntryID&quot;);       <br />&#160;&#160;&#160; modelBuilder.Entity&lt;SimpleEntry&gt;()       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Property(s =&gt; s.Name)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; .HasColumnName(&quot;SimpleEntryName&quot;); </p>    <p>&#160;&#160;&#160; } </p> </blockquote>  <p>We could then expose a query:</p>  <blockquote>   <p>public IEnumerable&lt;SimpleEntry&gt; GetSimpleEntries()     <br />{      <br />&#160;&#160;&#160; IObjectContextAdapter adapter = this;      <br />&#160;&#160;&#160; var entries = adapter.<font color="#ff0000"><strong>ObjectContext</strong></font>.CreateQuery&lt;SimpleEntry&gt;(&quot;SELECT VALUE MyEntry FROM MyEntry&quot;);      <br /></p>    <p>&#160;&#160;&#160; return entries;     <br />} </p> </blockquote>  <p>Here we fetch the underlying <em>ObjectContext</em> in order to query it.&#160; There advantage of this approach versus querying SQL directly is that we can query the resulting query further using LINQ and the final query sent to SQL will be the combined query.&#160; Therefore we can expose a query returning <em>everything</em> and simply query it with LINQ afterwards to obtain efficient query <strong>without ever materializing the entire table on the consumer side</strong>.</p>  <p>To convince ourselves that what I just said is true, let’s try it:</p>  <blockquote>   <p>public IEnumerable&lt;SimpleEntry&gt; GetSimpleEntries()     <br />{      <br />&#160;&#160;&#160; IObjectContextAdapter adapter = this;      <br />&#160;&#160;&#160; var entries = adapter.ObjectContext.CreateQuery&lt;SimpleEntry&gt;(&quot;SELECT VALUE MyEntry FROM MyEntry&quot;);      <br />&#160;&#160;&#160; var final = from e in entries      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#ff0000"><strong>where e.Name == &quot;Mark&quot;         <br /></strong></font>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; select e;      <br />&#160;&#160;&#160; var f = (System.Data.Objects.ObjectQuery&lt;SimpleEntry&gt;)final;      <br />&#160;&#160;&#160; var s = f.ToTraceString(); </p>    <p>&#160;&#160;&#160; return entries;     <br />} </p> </blockquote>  <p>If you debug this and look at the value of s, you’ll obtain:</p>  <blockquote>   <p>SELECT     <br />[Extent1].[SimpleEntryID] AS [SimpleEntryID],      <br />[Extent1].[SimpleEntryName] AS [SimpleEntryName]      <br />FROM [man].[MyEntry] AS [Extent1]      <br /><strong><font color="#ff0000">WHERE N'Mark' = [Extent1].[SimpleEntryName]</font></strong></p> </blockquote>  <p>This is your typical EF rendered TSQL but you can notice that the filter applied by the LINQ query got into the SQL query.</p>  <p>Now if you want to intercept INSERT, UPDATE &amp; DELETE on those tracked entities, you’re a bit on your own.&#160; You could override the <em>DbContext.SaveChanges</em>, pick entities with altered states, perform you db-logic to save the changes and switch the state of those entities back to <em>Unmodified</em> before calling <em>base.SaveChanges</em>.&#160; It’ll work but it’s start to be a bit on the stunt side.</p>