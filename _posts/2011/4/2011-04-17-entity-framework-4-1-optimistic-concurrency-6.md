---
title: 'Entity Framework 4.1: Optimistic Concurrency (6)'
date: 2011-04-17 12:13:00 -04:00
permalink: /2011/04/17/entity-framework-4-1-optimistic-concurrency-6/
categories:
- Solution
tags:
- .NET
---
<p>This is part of a series of blog post about Entity Framework 4.1.&#160; The past blog entries are:</p>  <ul>   <li><a href="http://vincentlauzon.wordpress.com/2011/04/03/entity-framework-4-1-basics-1/">Basics (1)</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/06/entity-framework-4-1-override-conventions-2/">Override conventions (2)</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/11/entity-framework-4-1-deep-fetch-vs-lazy-load-3/">Deep Fetch vs Lazy Load (3)</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/13/entity-framework-4-1-complex-types-4/">Complex Types (4)</a></li>    <li><a href="http://vincentlauzon.wordpress.com/2011/04/15/entity-framework-4-1-many-to-many-relationships-5/">Many to Many Relationships (5)</a></li> </ul>  <p>In this article, I’ll cover optimistic concurrency.</p>  <p>Very often we need to manage many-users concurrency.&#160; This is due to the speed at which humans interact with a machine compared to the speed machines interact with each other.&#160; Typically, a human will use the better part of a minute (often more) to fill a data form while a machine transactions usually takes less than a second.</p>  <p>We can’t keep SQL transactions open on the server while a user is editing the corresponding form for many reasons:&#160; contention, trust, technical reasons, etc.&#160; .&#160; For those reasons, we need to manage concurrency differently.&#160; There are two big schools on concurrency management:&#160; optimistic &amp; pessimistic.&#160; Pessimistic is typically more difficult since you need to implement some record-base locking mechanism and with it comes a lot problematic, such as how long should the system keep a lock before releasing it automatically.&#160; Optimistic concurrency is easier.</p>  <p>The basic assumption of optimistic concurrency is that user changes <em>rarely</em> clashes.&#160; This is true for applications with either few users or a lot of users but few users editing the same data at the same time.&#160; The basic idea is that you give the service consumer a version of the data and when the consumer comes back to update, it gives you back that original version.&#160; If the data changed in the back-end store and the version changed, the service can detect it and refuse the update.</p>  <p>Now the ‘version’ of the data can be different things.&#160; It could be a version number associated to your data, it could be a ‘last modified date’ date-time field, it could be more than one field.&#160; In Entity Framework, those are called <em>concurrency token</em>.&#160; In this article, I’ll use <a href="http://msdn.microsoft.com/en-us/library/ms182776(SQL.90).aspx">SQL Server time-stamp</a> feature:&#160; this involves adding a column with the time-stamp type on the tables where we want to implement optimistic concurrency.&#160; SQL Server takes care of updating this column each time a row is updated.</p>  <p>In order to tell Entity Framework that a property in an entity represents a concurrency token, you can either decorate the property with the <em>ConcurrencyCheck</em> attribute or use the model-builder.&#160; I consider that concurrency tokens should be part of the model since they define business rules, so I’m going to use the attribute:</p>  <blockquote>   <p>public class Order     <br />{      <br />&#160;&#160;&#160; public int OrderID { get; set; }      <br />&#160;&#160;&#160; [Required]      <br />&#160;&#160;&#160; [StringLength(32, MinimumLength = 2)]      <br />&#160;&#160;&#160; public string OrderTitle { get; set; }      <br />&#160;&#160;&#160; [Required]      <br />&#160;&#160;&#160; [StringLength(64, MinimumLength=5)]      <br />&#160;&#160;&#160; public string CustomerName { get; set; }      <br />&#160;&#160;&#160; public DateTime TransactionDate { get; set; }      <br />&#160;&#160;&#160; [<font color="#ff0000">ConcurrencyCheck</font>]      <br />&#160;&#160;&#160; [<font color="#ff0000">Timestamp</font>]      <br />&#160;&#160;&#160; public byte[] TimeStamp { get; set; } </p>    <p>&#160;&#160;&#160; public virtual List&lt;OrderDetail&gt; OrderDetails { get; set; }     <br />&#160;&#160;&#160; public virtual List&lt;Employee&gt; InvolvedEmployees { get; set; }      <br />} </p> </blockquote>  <p>With this code in, optimistic concurrency will take place when we call <em>SaveChanges</em> on the <em>DbContext</em>.</p>  <p>The timestamp property type is <em>byte[]</em>.&#160; By marking the property with the attribute <em>Timestamp</em>, the mapping to SQL Server is done to a time-stamp SQL type column.</p>  <p>Now, let’s simulate optimistic problem.&#160; The example here will go in three steps:</p>  <ul>   <li>Create an order</li>    <li>Simulate the modification of the order by a user X</li>    <li>Simulate the modification of the order by the user Y, while the order has been modified already without Y’s knowledge</li> </ul>  <p>The way to simulate modification is to attach the entity to another Db-context, simulating service boundaries.&#160; When we attach an entity to a db-context, it assumes the entity is unmodified, so we modify it afterwards.&#160; </p>  <blockquote>   <p>private static void ConcurrencyCheck()     <br />{      <br />&#160;&#160;&#160; Order originalOrder; </p>    <p>&#160;&#160;&#160; //&#160;&#160;&#160; Create an order     <br />&#160;&#160;&#160; using (var context1 = new MyDomainContext())      <br />&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; originalOrder = new Order      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderTitle = &quot;Paper&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CustomerName = &quot;*Bob*&quot;,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TransactionDate = DateTime.Now      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.Orders.Add(originalOrder);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; context1.SaveChanges();      <br />&#160;&#160;&#160; }      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Simulate the modification of the created order by user X      <br />&#160;&#160;&#160; using (var context2 = new MyDomainContext())      <br />&#160;&#160;&#160; {&#160;&#160;&#160; //&#160;&#160;&#160; Recreate the order object in order to attach it      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var order = new Order      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderID = originalOrder.OrderID,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderTitle = originalOrder.OrderTitle,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CustomerName = originalOrder.CustomerName,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TransactionDate = originalOrder.TransactionDate,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TimeStamp = originalOrder.TimeStamp      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context2.Orders.Attach(order); </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Alter the order     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; order.CustomerName = &quot;Robert&quot;; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context2.SaveChanges();     <br />&#160;&#160;&#160; }      <br />&#160;&#160;&#160; //&#160;&#160;&#160; Simulate the modification of the created order by user Y (after user X already modified it)      <br />&#160;&#160;&#160; using (var context3 = new MyDomainContext())      <br />&#160;&#160;&#160; {&#160;&#160;&#160; //&#160;&#160;&#160; Recreate the order in order to attach it      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var order = new Order      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderID = originalOrder.OrderID,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderTitle = originalOrder.OrderTitle,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CustomerName = originalOrder.CustomerName,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TransactionDate = originalOrder.TransactionDate,      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TimeStamp = originalOrder.TimeStamp      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; context3.Orders.Attach(order); </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; //&#160;&#160;&#160; Alter the order     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; order.CustomerName = &quot;Luke**&quot;; </p>    <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; try     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; context3.SaveChanges();      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; catch (DbUpdateConcurrencyException ex)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(&quot;Concurrency exception on &quot; + ex.Entries.First().Entity.GetType().Name);      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160; }      <br />} </p> </blockquote>  <p>You could also force EF to believe the order is modified:</p>  <blockquote>   <p>context3.Entry(order).State = EntityState.Modified; </p> </blockquote>  <p>So basically, EF supports optimistic concurrency out-of-the-box in a fairly simple form.&#160; The trick is more around state management with EF:&#160; when you attach entities to contexts, make sure they are in the right state:</p>  <ul>   <li>Detached</li>    <li>Unchanged</li>    <li>Added</li>    <li>Deleted</li>    <li>Modified</li> </ul>